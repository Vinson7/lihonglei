/*------------------------------------jQuery部分--------------------------------------*/
$(function(){});//该程序是在页面仅仅加载完DOM树后即可执行，而不必非要等到加载完视频，音频，图片flash等资源
jQuery.noConflict();//让$符号给其他库使用，eg:var jq=$.noConflict();将$符号改为jq去用jQuery
(function($){})(jQuery);
等价于：
var fn = function($){....};
fn(jQuery);//即直接运行此函数
jQuery对象：不是数组，是特殊的jQuery封装好的类数组对象；比如var a=$(".site-hd0");a instanceof Array;返回false
DOM对象：也不是数组，同样也是一种类数组的封装
typeof(document.getElementsByTagName("body"));
"object"
typeof($("body"));
"object"


/*-----------------------------第一章：选择器------------------------------*/

【$("selector选择器","环境的上下文（范围）");】

--基础选择器--
*                    匹配所有元素$("*")
E                    匹配标签为E的元素  $("div")
E F                  匹配标签为F，且F为E的子元素节点[子孙] $("div p")，找每一个div标签内所有p标签
E>F                  匹配标签为F，且F为E的直接子元素节点[亲儿子] $("div>p"),找每一个div中的亲儿子p标签

E+F                  匹配标签为F，且F为E后面的第一个兄弟节点(很实用，当<li>标签左侧浮动margin-left:时候经常出现第一个元素也要margin-left:非常不好调，
                      而此选择器可以跳过第一个，demo:li+li{margin-left:10px}，指每一个li标签后面的第一个兄弟li都会+10px距离，但对第一个li就不会增加margin-left！)
E~F                  匹配标签为F，且F为E后面的兄弟节点之一

E.C                  匹配E标签，且E拥有特性class="C"的节点，若省略E等价于：$(".C")  <E class="C"></C>
E#I                  匹配E标签，且E拥有特性id="I"的节点，若省略E等价于：$("#I") <E id="I"></E>
[A……]                直接操作特性值。demo：$("[page-num]")，查找具有page-num特性的元素
E[A]                 匹配拥有特性A的E元素：form[method],匹配了拥有method特性的form表单
E[A=V]               匹配拥有特性A且值为V的E标签：$("input[type='text']")，匹配了type 为text的input标签
E[A^=V]              同上，但是A的特性值以V开头
E[A$=V]              同上，但是A的特性值以V结尾
E[A!=V]              同上，但是A的特性值不等于V、或者说根本就不存在A特性
E[A*=V]              同上，但是A的特性值包含V

--通过位置/兄弟节点选择（css过滤器,纯css可以用）--

:first               匹配上下文中的第一个元素：li:first  匹配的是页面中（上下文）所有<li>标签中的第一个<li>
:last                同上，但是是最后一个元素
:even                返回偶数元素。li:even 返回页面中所有<li>的偶数项(从0计数的！！！0 2 4 6 8)
:odd                 同上，返回奇数项
:eq(n)               匹配第n个元素（注意：和nth:child(n)不同，它是匹配自身，nth:child(n)是先匹配父级然后再查找它的子集，后面有相应的eq()方法和这个功能一样,从0计数）
:gt(n)               匹配第n个元素之后的元素（不包含第n个）
:lt(n)               匹配第n个元素之前的元素（不包含第n个）

:first-child         匹配自身的父级元素中的第一个元素，demo：li:first-child,会匹配li标签的父级<ul>中的第一个<li>,而不是页面中所有<li>的第一个(那是:first)
:last-child          同上，它是匹配父元素中的元素，但返回的是最后一个子节点
:nth-child(n)        同上，它是匹配父元素中的元素，但返回第N个子节点 li:nth-child(2),返回每个<ul>标签的第2个li标签（只有他是从1开始计数的）
:nth-child(even|odd) 同上，它是匹配父元素中的元素，但返回对应的奇数/偶数子节点
:nth-child(Xn+Y)     同上，它是匹配父元素中的元素，但返回经过计算后的节点（n从0开始）；3n（能被3整除）   5n+1等

--jQuery自定义过滤器(只是jQuery可以用,css不可用)--

:animated            选择处于动画状态的元素；eg：某个div用animate({css},1000,callback);那就可以让此div发生样式变化
:button              选择按钮元素(input[type="submit"],input[type=reset],input[type=button],button)
:checkbox            选择复选框(input[type='checkbox'])type="button radio checkbox  hidden reset"
:radio               选择单选框(input[type='radio'])
                        <label>选项1</label>    <input type="radio" name="radio_test" value="a1" checked="checked"|checked/><br>
                        <label>选项2</label>    <input type="radio" name="radio_test" value="a2"/><br>
                        <label>选项3</label>    <input type="radio" name="radio_test" value="a3"/><br>
:checked             选择处于选中状态的复选框/单选框
                        <label多选1</label><input type="checkbox" name="checkbox_test" value="b1"/>
                        <label多选2</label><input type="checkbox" name="checkbox_test" value="b2"/>
                        <label多选3</label><input type="checkbox" name="checkbox_test" value="b3"/>
:selected            选择列表项中处于选中的<option>
                    <select>
                      <option value ="volvo" selected>Volvo</option>
                      <option value ="saab">Saab</option>
                      <option value="opel">Opel</option>
                      <option value="audi">Audi</option>
                    </select>

:file                选择文件输入元素(input[type='file'])
:header              选择标题元素<h1>到<h6>
:password            选择口令元素input[type='password']
:reset               选择重置按钮元素(input[type='reset']  button[type='reset'])
:submit              选择提交按钮元素(input[type='submit'] button[type='submit'])
:text                选择文本输入框元素(input[type='text'])

:contains(food)      选择包含文本food的元素（最好是直接的文本而不是子标签中的文本）,
                     $("p:contains(is)") 查找包含"is"字符串的<p>标签(注意：如果is字符串在p中的一个块级元素内是无法捕捉到的，如果在内联元素中，没问题)
                     把p标签中有is字符串的p标签背景颜色改变
                     eg：<p class="intro">My name<section>is</section> Donald</p>——无效
                         <p class="intro">My name<span>is</span> Donald</p>——有效
:has(selector)       选择包含指定selector的父节点 $("p:has('span')")，意思是说找到包含span标签的p元素)
:not(selector)       选择不匹配selector的元素：eg:$("img:not([src*='dog'])")，是找出图片中src没有“dog”字符串的图片

:disabled            选择处于禁用状态的元素
:enabled             选择处于可用状态的元素

:hidden              选择隐藏元素(把透明度降低到0，也相当于隐藏)
:visible             选择可见元素




/*----------------------------包装集相关常用方法--------------------------*/

length属性                                       返回的jQuery对象匹配的DOM元素的数量(原来可用size()方法，在1.8中删除，而且调用属性比方法开销要小)
get(i[正/负]/不写参数)       等价于$("li")[i]写法；i从0开始计数，若get()不写参数则返回由DOM节点组成的【数组】，若写参数(正数)返回指定的DOM对象（不是jQuery对象），负数则从后面数，eg：-1表示倒数第一个
eq(i)                       获取包装集中指定的某个jQuery对象(返回的是新的包装集);相当于：$($("li").get(0))===$("li").eq(0)
first()                     获取包装集中第一个元素(返回的是新的包装集);若原来的包装集为空，则返回空
last()                      获取包装集的最后一个元素(返回的是新的包装集);若原来的包装集为空，则返回空
children(selector/不写)     只找其子集(不会寻找其孙或者更后面的节点)
toArray()                   将包装集中的所有元素转换为DOM元素并封装为数组返回；和get(无参数)方法一样
index(element)              element:选择器/DOM元素/不写($(this).index())    获取dom节点本身在“兄弟【这个兄弟不一定是同种类，如下例子】”节点中的位置；若未找到，返回-1
                            注意：$("X").index("Y")，是从X范围开始查找的，
                            eg：
                                <div></div>
                                <p><p>
                                <p id="x" class="active"><p>
                                <p><p>
                                <div></div>
                                $("p").index("active")——>1，范围锁定在 <p>标签上，所以active是相对p而言的【点击某个类A，获取这个节点在类A中的位置：$(".A").index($(this))】
                                $("#x").index()——>2   #x 的位置是相对所有兄弟节点而言的，因为index()中没有写范围


add(expression,上下文)         expresession(选择器|html元素|DOM元素、DOM数组)，
                                                        返回值：添加了expression的原始包装集的副本（并集）注意：add()仅仅是产生了包装集副本并没有改变DOM树
例子：$("img[alt]").add("img[title]"):在img有alt特性的包装集中增加img有title特性的元素
$("p").add("<div>aaa</div>"):正如上面所说的这里没有改变DOM树，仅仅是产生了改变的包装集副本（以后还可以回滚）

slice[begin,end)                       截取并返回新的包装集，[begin,end)不包含结尾，从0计数 
                                                        eg:slice(2,3):获取新的由第三个元素组成的新包装集，若只有一个参数slice(4),就会获取从第5个开始到最后的所有节点

【包装集过滤遍历 not filter find has each map】
not(expression)                            删除自身包装集种满足expression的节点(过滤本身)；相似的方式：$("选择器:not("选择器")")
                                                        expression(选择器|html元素|DOM元素、DOM数组|函数)，返回值：创建副本，删除 与expression相匹配的元素
                                                        若是函数not(function(index,当前dom)：则为调用者的每个元素调用，如果函数返回true则删除此包装集的节点，反之保留
                                                        例子：$("img").not(function(index,当前dom)
                             {
                                 return $(this).hasClass("XXX");
                             }
                             })
                                                         删除img中有类为XXX的img元素，并返回副本；$("img['title']").not("[title*='abc']");

filter(expression)              保留自身包装集中满足expression(选择器|html元素|DOM元素、DOM数组|函数[如果函数返回true则保留])——和not()方法恰好相反，
                                                        返回值：创建副本，保留 与expression相匹配的元素
                                                        如果是函数：若返回true则保留，false则删除

has(selector)                                返回新的包装集，这个包装集包含了原始包装集中的“子节点”中匹配selector的包装集;selector:(选择器|dom元素);通过子元素过滤本身 
                            eg：$("div").has("img[alt]")：返回了这样的div，它的子元素中有alt特性的img元素

find(selector)                            返回与原始包装集中传入的selector相匹配的所有子元素构成的新的包装集，它会搜索调用者包装集中每一个元素的“后代”（不包括本身）且匹配selector的元素
                               eg:$(".A").find("li")结果是：除了.A 这个li标签，其他他的子所有<li>都被返回了，因为它是从本身的子集开始搜索的
                               <li class="A">
                                     <ul>
                                       <li>
                                         <ul>
                                           <li></li>
                                         </ul>
                                       <li>
                                     </ul>
                                  </li>
map(callback(index,element))      返回新的包装集（由转换的值组成） 遍历包装集，为包装集中每一个元素调用callback函数，callback(index-0开始,DOM元素本身this)
                                   eg:var allIds=$("div").map(function()
                                   {
                                     return (this.id==undfined?null:this.id)//将每一个元素的id值放入包装集中
                                   }).get();//将新的转换好的包装集转为由dom构成的数组
each(callback(index,element))     基本和map一致，但是有个地方不同：each()它不用生成返回值，即不会在回调函数中有return，它仅仅是处理了每一个对象，不像map会收集元素信息，然后把信息转为新的包装集

【注意：在遍历中如果有return false;那么并不会中止遍历所在的函数或者触发的事件，终止的仅仅是本次循环】
【注意】这里区别一下：filter(是对自己的一种过滤)；而find()则是自己的子节点)，
eg：
  <div></div>
  <div class="middle"></div>
  <div></div>

$("div").css("background", "#c8ebcc").find(".middle").css("border-color", "red");
结果是：.middle类没有被加上color，原因是：find是查找调用者包装集中每一个节点的子元素，它不会从自身开始查找，而是后代节点查找
他的每一个div都没有“子”标签含有.middle；若换成filter则就会有效果；filter是针对自身包装集的元素


is(selector)           判断包装集中是否存在与传入的选择器表达式相匹配的元素，只要有一个满足就返回true/false
                                        eg：
                                        <ul>
                                              <li><strong>list</strong> item 1 - one strong tag</li>
                                              <li><strong>list</strong> item <strong>2</strong> - two <span>strong tags</span></li>
                                              <li>list item 3</li>
                                        </ul>
                                        $("li").click(function() 
                                        {
                                            //点击每一个li标签有如下判断
                                          var $li = $(this),                            //获取被点击的li                                          
                                        isWithTwo = $li.is(function()        //isWithTwo函数判断被点击的<li>中是否有两个<strong>标签，并返回boolean值
                                        {
                                          return $('strong', this).length === 2;
                                        });

                                          if ( isWithTwo )
                                          {
                                            $li.css("background-color", "green");
                                          } else
                                          {
                                            $li.css("background-color", "red");
                                          }
                                        });

end()              回滚到前一个包装集；这个方法主要是体现在链式编程中，回滚到调用end()的包装集的上一个包装集：eg:$("img").filter("[title]").hide().end();此时回滚到$("img")处

---利用关系获取包装集---
closest(selector)            返回原始包装集中(查找从自己开始)每个元素上一级(一直向上找，直到满足)中满足selector的 最近 的父类节点；（一般用来寻找父级且满足的唯一节点）
parent(selector|无参数)       返回原始包装集元素的每个元素(查找的起点不包含自己)的"直接"父元素组成的包装集,如果父级没有满足的，则终止；
parents(selector|无参数)      返回原始包装集元素的每个元素(查找的起点不包含自己)的所有祖先元素组成的包装集(和上面的parent(),如果父级没有，就会依次向上找，一般不止找到一个)

next(selector|无参数)       返回原始包装集元素后面下一个同级元素(只是弟弟)组成的包装集  注意可能兄弟节点根本不是同一个标签
eg:  <p>Hello</p>
     <p class="selected">Hello Again</p>
     <div class="selected"><span>And Again</span></div>
     <script>
       $("p").next(".selected").css("background", "yellow");//运行完后：会发现第二个p和最后一个div都变成黄色，
     </script>
siblings(selector|无参数)   返回的是同级的兄弟节点(不包含自己) 【注意可能兄弟节点不一定是同类型标签】




/*-----------------------------第二章：操作特性、css、页面内容(DOM 结构)------------------------------*/

对于HTML5：自定义特性方式是：data-才能被承认会通过官方认证   <div id="custom" data-custom_id="1"></div>
对于HTML4：自定义特性虽然可用但是官方无法通过，且标记无效

attr(name)         包装集获取名字为name的特性值：attr("id")
attr(name,value)   包装集设置名字为name的值为value
attr(json)         同时设置多个值：attr({"id":"value1","class":"value2"})
removeAttr(name)   删除某个特性
/*
    有趣的问题：
    1、双重提交问题
       $("form").submit(function(){
         $(":submit",this).attr("disabled","disabled");
         this指向form表单代表范围，也就是说:submit是在form中的submit
       });
    2、enabled  和  disabled
       只要在按钮，表单啊等用了disabled，不用赋值，元素即会变为“不可用”状态，根据W3C正是由于disabled的存在（不是特性值）才使得元素被禁用，它是什么值根本无所谓
       哪怕是：attr("disabled","enabled")也是不起作用；
       解决方式：1-删除此特性，即removeAttr("disabled")
                2-利用jQuery将其值改为boolean值：$(":submit").attr("disabled",false);即可
*/
addClass(字符串|函数)     字符串：若有多个则以空格分割；若为函数function(index元素下标,当前节点){return "添加的类名"}，多次添加同一个类名无效即只会增加一个
removeClass(字符串|函数)  参数意义同上，与其相反，函数的返回值作为要删除的名称
toggleClass(字符串|函数)  参数意义同上，如果传入了类名不存在，则增加，如果有了，则删除
hasClass(nameClass)      判断某个包装集中的元素是否拥有nameClass参数传入的类名，返回true/false;(此方法和is()方法很相似，但是性能更好)


css(name,value)                                  name:css属性名字；value:字符串|数字|函数(index,css当前值)
css(json对象)                                    json对象{"name1":"value1","name2":"value2"}
css(name)                                        获取包装集中第一个元素的名字为：name的css属性的值。
                                                                        【注意：此方法只会返回string类型的数据，所以对于原本是数字值的数据要特别小心，必须重新转换为数值-parseInt("数值字符串")】
width|height(value|不写参数)           不写参数就直接获取包装集中第一个的宽度/高度:单位：像素；value：可以是数字（默认以像素为单位），也可以是"100px""100em""50%"样子的字符串
定位：
offset()                     返回一个对象，这个对象可以调用top，left两个属性，从而获得/设置相应的top值，和left值，单位px，这个值是相对于文档参照原
position()                   返回一个对象，这个对象可以调用top，left两个属性，从而获得/设置相应的top值，和left值，单位px，
                                                    这个值是相对于最近偏移父元素（应当有定位为relative或者position）为参照原的相对位置，所以不适合用在非定位状态的元素！
                                                    eg：<div> 如果div用了padding：10px，则p的top偏移量为10px，即对于盒子模型而言p的position就是对外层的距离（并不是margin）
                                                                <p><p>
                                                            </div>
【注意：这两个方法无法用在隐藏的块上面，同样padding margin border也一样】
滚动：
scrollLeft(Number值|不写值)   设置|返回包装集中第一个元素的水平滚动偏移值(返回的是数值，传入的也是数值)，调用者本身应该有滚动条出现
scrollTop(Number值|不写值)    设置|返回包装集中第一个元素的垂直滚动偏移值


操作内容：
html()           获得包装集中第一个元素的所有html代码
html(content)    content:字符串|函数function(index,当前元素内容)    若为函数：则为每一个包装集元素调用，返回值作为新的内容
text()           将包装集中所有元素的文本连接起来，返回一个字符串文本，注意上面的可以得到标签，text()只能得到文本
text(content)    同html(content)
val()            针对表单，返回包装集中“第一个”元素的value值，注意：如果“第一个”元素是多选的，则返回数组
val(values)      导致单选框/复选框/下拉的元素变为选中状态，只要传入的数组值和任意一个匹配即可

                 特别注意：html()和text()会替换原来的内容，所以要特别小心

append(字符串|DOM元素|jQuery对象|函数)       A.append(B),把B增加到A内容的尾部，若A有多个元素，则B先是复制然后移动，若A只有一个则直接移动B；而B若是源文档中的，则源文档中的B必被删除
prepend(字符串|DOM元素|jQuery对象|函数)      把B放在A内容的前面,其他同上
appendTo(字符串|DOM元素|jQuery对象)          A.append(B)===B.appendTo(A)
prependTo(字符串|DOM元素|jQuery对象)         A.prepend(B)===B.prependTo(A)

before(字符串|DOM元素|jQuery对象|函数)   A.before(B) 把B当做A的兄弟节点放在A的前面(不是内容前面)
after(字符串|DOM元素|jQuery对象|函数)    A.after(B) 把B当做A的兄弟节点放在A的后面(不是内容前面)
insertBefore(字符串|DOM元素)      A.before(B)===B.insertBefore(A)
insertAfter(字符串|DOM元素)       A.after(B)===B.insertAfter(A)

detach(不写||selector)         删除包装集节点，但它和remove不同之处是会保留删除的jQuery对象(返回值)，合适的时候可以再恢复，且保留数据和事件(建议用这个)
eg：<body>
          <p>Hello</p>
              how are
          <p>you?</p>
          <button>Attach/detach paragraphs</button>
            <script>
                $("p").click(function(){
                  $(this).toggleClass("off");
                });
                var p;
                $("button").click(function(){
                  if ( p ) {
                    p.appendTo("body");
                    p = null;
                  } else {
                    p = $("p").detach();
                  }
                });
        </script>
        </body>
remove(不写||selector)         从页面DOM中删除包装集中的所有元素（且删除绑定在其上的数据和事件），若添加参数selector，则可以进一步过滤；返回值：删除的包装集
empty()                              会删除包装集中所有子节点（且删除绑定在其上的数据和事件）(如果仅有文本也会删除)
clone(boolean)                       复制调用的包装集，并返回此包装集，参数若为false/不写，则不复制事件处理器;一般的用法是复制后再附加到页面的某个dom节点
replaceWidth(字符串|DOM|jQuery对象|函数)     替换每一个包装集中的元素(如果是$("p").replaceWidth($("span"))中<span>是已经存在的，则span会被移动而不是复制！);
                                                                                        返回值：被移除的包装集(不是替换的包装集)
                                                         $("p").replaceWith("<b>Hello world!</b>");
                                                         <p>This is a paragraph.</p>
                                                         <p>This is another paragraph.</p>
                                                         变为：    <b>Hello world!</b>
                                                                     <b>Hello world!</b>
replaceAll(字符串|DOM|jQuery对象)            A.replaceAll(B),是A替换B，和上面的刚好相反;(A和B都是DOM节点，不是字符串)





/*-----------------------------第三章：事件------------------------------*/

1、对于所有的事件都会传入一个event参数，但是IE比较特别：需要首先判断浏览器是否支持event然后把保存在全局变量中的event的IE的event取出来；
if(!event)
{
      event=window.event;//或者var event =event||window.event;
}

获取按键码：event.keyCode || event.which(jquery) || event.charCode 针对不同的浏览器获取按键码
回车键是：13
2、冒泡问题：但我们触发任意一个节点的事件（click，hover……），那么事件并没有仅仅在触发的地方发生了，而是沿着它的父类继续向上层触发，如果父类有同样的事件就会被触发
注意：仅仅是触发父类而不是，兄弟节点！！！
3、结束事件：常用的方法是对于触发的事件：return false;


on(event,data,function(event|不写){})        event:(string)事件名称，可以以空格分割多个事件，从而绑定多个事件
                                             data:(对象)用来附件在event上
                                             函数：默认会传入event参数
on(JSON表达式)                               同时绑定多个不同的事件eg:{"click":function(event){},"mouseenter":function(){}}

可以绑定的事件列表：
                    blur                focusin                  mousedown                   mouseup
                    change[下拉，多选，单选]              focusout                 mouseenter                  ready
                    click               keydown                  mouseleave                  resize
                    dbclick             keypress                 mousemove                   scroll
                    error               keyup                    mouseout                    select
                    focus               load                     mouseover                   submit
                                        unload
                                        增加：cut copy paste
                                        input(针对IE外的浏览器，且只针对value值变化才会触发)
                                        propertychange(主要是针对IE浏览器的)

【浏览器事件】
error()/1.8弃用/                        当元素遇到错误（没有正确载入）时，发生 error 事件;【注意：此方法一般是依赖HTTP请求的，即本地测试(file://)会无效】
                                        eg：$("img").error(function(e){}).attr("src","error.png");【注意：“错误函数”必须在“处理函数”之后，即error()需要在attr()之前执行】
resize()                                当调整对象尺寸时发生，常用于$(window)
                                        eg：$(window).resize( function(){
                                            alert("不建议调整窗口大小!");
                                        } );
scroll()                                页面滚动时触发：常用$(window).on("scroll")//.scroll(function(){});
【文档加载事件】
load()/1.8弃用/                        	当元素被完全加载完成后就会触发，建议放在.ready()中，因为：.ready()会在DOM准备好就会执行，而load()则是完全载入
unload()                                当离开某个页面时(包括重新加载页面时也会触发)，会触发此事件
【绑定事件的处理器】
on(event,selector,data,Fun(event)||false)        event:绑定的事件;selector:过滤的选择器;data：通过触发函数的event.data调用来使用，可以是任意数据
【注意：selector写和不写的区别：
1、如果不写那么触发事件的就是调用的对象——叫做直接事件;相反如果写入了selector——叫做委派事件 
2、当处于“委派事件”状态下，调用者/绑定者不会去触发事件，只有当selector被匹配到的时候才会触发,而且处于委派事件状态下可以匹配“未来”元素，即动态增加的DOM元素时
(指的是selector增加时)，这个新增加的DOM依旧可以绑定事件而不用live()方法;
3：性能差别：假设<div><p></p>此处1000个p标签</div>：(1)$("div p").on("click")——一次绑会为1000个元素绑定事件  (2)$("div").on("click","p");仅仅是绑定了1个元素
】

blur():          某个表单元素失去焦点时触发的事件
focusin():       <div><input ……></div>如果div标签内的inpu获得焦点，$("div").focusin(function(){}那么div就会触发focusin;对于focus而言，他只针对自身是否获得焦点
focusout():      <div><input ……></div>如果div标签内的inpu失去焦点，那么div就会触发focusout;
mousedown():     当“按下”鼠标按钮（不是点击click，只是按下）触发的事件;
mouseup():       和mousedown相反是“松开鼠标”时触发的事件;
keypress():      与keydown非常像，都是按下按钮就触发事件
change():        当改变某个元素的值时就会触发，注意：该事件仅适用于文本域（表单<input>为text|field），以及 textarea 和 select 元素;
                当用于 select 元素时，change 事件会在选择某个选项时发生。当用于 text field 或 text area 时，该事件会在元素失去焦点时发生

mouseenter():    只对绑定的元素有效:当进入其元素时触发，而且进入其子元素不会触发；
mouseleave():    通常和mouseenter绑定在一起
mouseover():     不仅对绑定的元素有效:当进入其元素时触发，而且进入其子元素也会触发；
mouseout():      通常和mouseover一起用
mousemove():     当鼠标指针在指定的元素中移动时，就会发生 mousemove 事件。比如获取坐标

ready():         与这个函数等价，当页面DOM以及所有图片……等加载完成后触发，一般用jquery自带的$(function(){});
error():         

resize():        当调整浏览器窗口的大小时，发生 resize 事件
scroll():        当用户滚动指定的元素时，会发生 scroll 事件
select():        当文本被单击左键拖拽选中时触发，比如：选中一段文本，改变选中文本的背景色+文本颜色(可以利用css3的::selection 处理)
load()：         当指定的元素（及子元素）已加载时，会发生 load() 事件。该事件适用于任何带有 URL 的元素（比如图像、脚本、框架、内联框架）。根据不同的浏览器（Firefox 和 IE），如果图像已被缓存，则也许不会触发 load 事件
unload():        具体来说，当发生以下情况时，会发出 unload 事件：
                 .点击某个离开页面的链接
                 .在地址栏中键入了新的 URL
                 .使用前进或后退按钮
                 .关闭浏览器
                 .重新加载页面
submit():        提交表单

在使用on("事件",function(event))  event都会以第一个参数传进去，这个event和原生的js是有区别的，因为此event屏蔽了浏览器之间的差异性,而且传进去的event并不等同于原生js的event

event的属性
pageX pageY         以文档左上角为参考
screenX screenY     以屏幕左上角为参考
preventDefault()    阻止默认的语义动作<a>无法超链接
stopPropagation()   阻止冒泡

------H5特有的触摸事件------
touchstart事件    ：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。
touchmove事件     ：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。
touchend事件      ：当手指从屏幕上离开的时候触发。
touchcancel事件   ：当系统停止跟踪触摸的时候触发
上面的这些事件都会冒泡，也都可以取消。虽然这些触摸事件没有在DOM规范中定义，但是它们却是以兼容DOM的方式实现的。所以，每个触摸事件的event对象都提供了在鼠标实践中常见的属性：
bubbles(起泡事件的类型)、cancelable(是否用 preventDefault() 方法可以取消与事件关联的默认动作)、clientX(返回当事件被触发时，鼠标指针的水平坐标)、clientY(返回当事件触发时，鼠标指针的垂直坐标)、screenX(当某个事件被触发时，鼠标指针的水平坐标)和screenY(返回当某个事件被触发时，鼠标指针的垂直坐标),除了常见的DOM属性，触摸事件还包含下面三个用于跟踪触摸的属性。

touches：表示当前跟踪的触摸操作的touch对象的数组。
targetTouches：特定于事件目标的Touch对象的数组。
changeTouches：表示自上次触摸以来发生了什么改变的Touch对象的数组。

每个Touch对象包含的属性如下。

clientX：触摸目标在视口中的x坐标。
clientY：触摸目标在视口中的y坐标。
identifier：标识触摸的唯一ID。
pageX：触摸目标在页面中的x坐标。
pageY：触摸目标在页面中的y坐标。
screenX：触摸目标在屏幕中的x坐标。
screenY：触摸目标在屏幕中的y坐标。
target：触目的DOM节点目标

/*-----------------------------第四章：动画------------------------------*/
hide(speed,callback)         使元素变为隐藏的状态(display:none)，若指定speed则在X毫秒内执行动画效果，若不指定，则瞬间完成;callback则是在动画执行完后执行回调函数
show(speed,callback)         使元素变为显示的状态(display:none)，若指定speed则在X毫秒内执行动画效果，若不指定，则瞬间完成;callback则是在动画执行完后执行回调函数
toggle(speed,callback)       上面两个方法的整合，功能是：切换hide(),show();
toggle(布尔表达式)            如果是true——显示，false——隐藏

fadeIn(speed,callback)       使元素的不透明度变为初始值，而且是渐变，其他参数同上
fadeOut(speed,callback)      使元素的不透明度变为0%，而且是渐变，其他参数同上
fadeTo(speed,opacity,callback)        使元素的不透明度到opacity(0.0~1.0) 其它参数同上

slideDown(speed,callback)    下拉、使元素显现出来
slideUp(speed,callback)      上拉、使元素隐藏起来
slideToggle(speed,callback)  切换上拉，下拉

stop(是否停止整个队列的动画,是否允许当前动画完成)   如果只写stop()默认值是false,false，即允许队列中的其他动画执行，不允许当前动画执行完毕(即比如执行一半了，不得不执行第二个队列中的动画)
                                                 如果是false,true;那第一个执行一半的动画马上会到动画的结尾状态(突然的)，然后以动画形式执行第二个队列动画
                                                 如果是true，false则是动画“暂停”的效果

animate(css,time,callback()/函数名)      注意：此方法只支持有数值的css；不可以改变像颜色的字符串类型
                                        css:json表达式，表示要执行的css的最终结果；time:毫秒/slow/normal/fast这三个字符串(假设调用了多个animate()方法，那么这几个animate是进入动画队列的
                                        而如果在一个包装集用fadeIn()d等特效，则不会进入动画队列，即是非阻塞的同时执行，所以在做某些特效时，比如一个消失，一个显示，就可能出现无过度效果；
                                        其原因就在于他们是几乎同时开始的，所以常用办法就是在第一个动画执行时增加时间，等过了X毫秒后再回调第二个动画)
                                        function aniDiv(){
                                            $("#box").animate({width:300},"slow");
                                            $("#box").animate({width:100},"slow",aniDiv);
                                          }
                                          aniDiv();

queue(name,function)        name:队列名称；function:添加到队列结尾的元素
dequeue(name)               每次都会执行一个队列中的函数，并且删除队列中的函数，如果想一次就执行所有的队列函数，则可以在函数的末尾加上dequeue(name)从而形成链式反应
clearQueue(name)            清除所有未执行的队列中的函数
delay(time,name)            time:毫秒；name:队列名称，其实这个方法不是一定要用在队列中，普通如fadeIn特效也可以用；eg:$("X").delay(1000).fadeIn(500)


/*-----------------------------第五章：与DOM无关的$函数------------------------------*/
var jq=$.noConfilct();把$符号转变为jq字符
(function($){…………})(jQuery);在函数内部指向$;

$.trim(字符串)      删除字符串开头和结尾的空白(空格、换行符、回车、制表符等)  返回修改后的字符串
$.each(数组|对象,callback)       遍历传入函数的数组/对象的每一项，并且为每一个调用回调函数；callback(index|属性名字，数组项|属性值)     返回容器对象
                                $.each(array,function(index,value)
                                {
                                   $("ul").append("<li>"+value+"</li>");
                                });
$.grep(array,callback,invert)   array:数组;callback:若遍历某个数组元素并返回true则次元素被收集，否则不收集(注意：此函数参数顺序和$.each()相反)，invert:反转，即如果为true，则
                                当回调函数返回false时才会收集数据。
                                返回值：由收集的值返回的数组
                                eg:返回那些值大于100的数组元素：$.grep(array,function(value){return value>100})
$.map(array,callback)           array:数组;callback(value,index):他的返回值将被收集到一个新的数组中，这个新的数组即返回值；注意：如果返回的值是：null undefined 那么结果不会被收集
                                这样出现的问题就是：原始数组和新生成的数组不是一一对应的

$.inArray(value,array)          返回数组中value值所在array中的位置,若没有则 返回-1
$.makeArray(object)             将传入的类似数组的object转换为JavaScript数组
其实所谓的“类似”数组的对象：{"1":"a","2":"b"} 或者DOM或者String的字符串都是可以的      eg:<div>First</div>
                                   <div>Second</div>
                                   <div>Third</div>
                                   <div>Fourth</div>
                                   <script>
                                   // 返回nodelist节点
                                   var elems = document.getElementsByTagName( "div" );
                                   // 转换为数组
                                   var arr = jQuery.makeArray( elems );
                                   // 反转数组元素
                                   arr.reverse();
                                   $( arr ).appendTo( document.body );
                                   </script>输出：Fourth   Third    Second    First

                                   var obj = { 0:"CodePlayer", 1: "Hello", 2: 18, 3: true };
                                   // 类数组对象不是真正的数组
                                   w( obj instanceof Array ); // false

                                   var arr = $.makeArray( obj );
                                   w( arr instanceof Array ); // true
                                   w( arr.join(" ") ); // CodePlayer Hello 18 true
                                   w( arr.length ); // 4

                                   $.makeArray( "CodePlayer" );
                                   返回：["CodePlayer"]



$.unique(array)                 array：DOM元素的数组，返回DOM数组中不重复元素组成的数组
$.merge(array1,array2)          合并数组：把2数组加到1数组上(重复的元素也可以)，把改变的1数组当做返回值返回
                                var array1=[1,2,3];var array2=[3,4,5];$.merge(array1,array2);->[1,2,3,3,4,5]
$.extend(deep,target,source1……)         deep:深复制还是浅复制，false/省略为浅复制，true是深复制；target：目标对象；source：原对象
                                        函数的意义是：把source1……添加到目标对象，而且如果是相同的属性则覆盖前面的
                                        比如：target={a:1,b:2,c:3};source={c:4,d:5,e:6};source2={e:7,f:8;g:9}  $.extend(target,source1,source2)
                                        结果：{a:1,b:2,c:4,d:5,e:7,f:8,g:9}因此可以看到：后面的对象拥有更高的优先级

/*---------------JSON和String字符串之间的转换------------------*/
$.param(params,[traditional])     params:数组|jQuery|对象，返回值：格式化后的查询字符串
                                  $.param({a:1,b:2})   生成'a=1&b=2'这个字符串（其实就是提交参数时的url中的一些参数eg:http://dkdkdkdk?a=1&b=2）
$.parseJSON(string_json)或者JSON.parse(string_json)  json:是将“严格按照JSON格式”（即：属性名必须是以双引号）的字符串转换为JSON对象
                                                    eg：JSON.parse('{"a":"1","b":"2"}');（外边必须是单引号，内部json格式是双引号，必须严格）
                                                        JSON.parse('{"a":1,"b":2}');这么写也可以！只要保证外边的key是有双引号即可
                                                       Object {a: "1", b: "2"}
JSON.stringify(json_obj)               将JSON转为字符串


$.isArray(o)                      如果o是JavaScript数组，则返回true，就算是类似数组（比如jq包装集）就会返回false
$.isEmptyObject(o)                如果o对象不包含任何属性，则返回true，如果o有从继承过来的属性则返回false
$.isFunction(o)                   如果o是JavaScript函数类型则返回true；但是在IE中alert(),confirm()那些弹窗是无法被当做函数的
$.contains(dom1,dom2)             判断dom2是否包含在dom1中，若是：返回true，反之false
                                  eg:  $.c？ontains( document.documentElement, document.body ); // true
                                       $.contains( document.body, document.documentElement ); // false
$.data(用于存储/取出数据的dom元素,name数据名称,value设置数据值，如果省略则是取出数据值)      存储或者获取数据值
$.removeData(dom元素，name数据名称)     删除在dom上的数据，无返回值
$.getScript(url,[callback])       url:脚本的url,callback()函数是在js文件请求到后，并且运行完毕后执行(请求后的js默认会运行一遍)



扩展jquery：
(function($){
        必须写在这个里面！！！
        必须写在这个里面！！！
        必须写在这个里面！！！
})(jQuery);
}
---类级别:即不是为了操作DOM对象，如$.ajax(……)---或者StringObj.slice();

        <方式1-参数只有一个对象，扩展了jQuery本身>
        $.extend(
        {
            add:function(a,b){return a+b;} ,
            minus:function(a,b){return a-b;
        }
        });

        <方式2-在某个prototype原型类上增加函数，扩展某个已经存在的类，比如String>
        $.extend(String.prototype|target,{functionName1:functionContent1,functionName2:functionContent2});target会被对象123……N覆盖

        <方式3-直接$添加一个方法>
        $.say=function(data){alert("这里就是传入的数据"+data);}

---DOM级别；如#("包装器").方法---
jQuery源码：
jQuery.fn = jQuery.prototype = {

　　　init: function( selector, context ) {.....};
};
所以：$.fn.extend(obj)就是扩展了原型

$.fn.extend(
{
    check:function()
    {
            return this.each(
            {
               this.checked=true;
            });
    },

    uncheck:function()
    {
            return this.each(
            {
               this.checked=false;
            });
    }
});

或者
$.fn.函数名=function(){…………}



/*-----------------------------第八章：ajax------------------------------*/
url?callback=?这种形式要在jQuery>=1.2版本才可以用
$(选择器).load(url,parameters,callback(data))       url:字符串，服务器资源的url
                                              parameters:(字符串|对象|数组)；指定要作为请求参数的数据，若为对象()/数组：则采用post请求，若为字符串：则为get请求方式
                                              callback:传入此函数的有：响应的文本，状态字符串（通常是success），以及XHR实例
                                              $("选择器").load("url");把请求的数据直接注入到选择器中
$.get(url,parameters,callback(data),type)     发起get请求
                                              url:(字符串)服务器资源的URL
                                              parameters:(字符串|对象|数组)，作为请求参数传递的任何数据；对象（其属性被正确的序列化为正确的编码）；或者由对象组成的数组
                                              callback:第一个参数：根据type类型返回的数据data；第二个参数：文本信息；第三个参数包含XHR实例的引用
                                              type:指定如何解析响应的主体：html，text，xml，json，script或者jsonp
                                              注意：和$(选择器).load不同，它不会直接插入指定DOM位置的数据，而是需要手动处理
                                              eg:$.get("http://xxx.abc.com/s/get.jsp",{"name":"lihonglei"},function(data,textMessage,XMLHttpRequestObj){……},"jsonp")

$.post(url,parameters,callback(data),type)  参数同上，但是使用post获取
$.getJSON(url,parameters,successCallback(data))    参数同上，但是这个方法是通过get方式请求数据
                                            $.getJSON("http://api.flickr.com/services/feeds/photos_public.gne?tags=cat&tagmode=any&format=json&jsoncallback=?", function(data) {
                                                $.each(data.items, function(i, item) {
                                                    $("<img/>").attr("src", item.media.m).appendTo("#images");
                                                    if (i == 3)
                                                        return false;
                                                });
                                            });
                                            $.getJSON(url,{"name":"lihonglei","age":"30"},回调函数(data));
$.ajax()                               $.ajax(
                                          {
                                              url: '/Resources/GetList.ashx',
                                              type: "post",          //post或者get请求方式，如果不写默认是get
                                              dataType: "jsonp",      //用来识别返回的类型;xml,html,json,jsonp,script,text
                                              data: dataurl,         //发送过去的数据（字符串|数组|对象）
                                              timeout: 1000              //毫秒值，若超时则调用error函数，如果有写的话
                                              jsonp: "callback",     //传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback)
                                              jsonpCallback:"callBackFunction"
                                              类型：String
                                              在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 "callback=?" 这种 GET 或 POST 请求中 URL 参数里的 "callback" 部分，
                                              比如 {jsonp:'onJsonPLoad'} 会导致将 "onJsonPLoad=?" 传给服务器。
                                              success: function (data)
                                              {
                                                  if (data != "") {
                                                      $("#pager").pager({ pagenumber: pagenumber, pagecount: data.split("$$")[1], buttonClickCallback: PageClick });
                                                      $("#anhtml").html(data.split("$$")[0]);

                                                  }
                                              }
                                              error:  function(){……}
                                          });
参数详解：
url:         要求为String类型的参数，（默认为当前页地址）发送请求的地址。
type:        要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。
timeout:     要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。
async：      要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。
cache：      要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息。
data:        要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看processData选项。对象必须为key/value格
             式，例如{foo1:"bar1",foo2:"bar2"}转换为&foo1=bar1&foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:["bar1","bar2"]}转换为&foo=bar1&foo=bar2。
dataType:    要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：
             xml：返回XML文档，可用JQuery处理。
             html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。
             script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。
             json：返回JSON数据。
             jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。
             text：返回纯文本字符串。
beforeSend：  要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。
                function(XMLHttpRequest){
                   this;   //调用本次ajax请求时传递的options参数
                }
*complete：    要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。
              参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。
                  complete : function(XMLHttpRequest,status){ //请求完成后最终执行参数
             　　　　if(status=='timeout'){//超时,status还有success,error等值的情况
              　　　　　 ajaxTimeOut.abort(); //取消请求
             　　　　　  alert("超时");
             　　　　}
success：         要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。
                 (1)由服务器返回，并根据dataType参数进行处理后的数据。
                 (2)描述状态的字符串。
                 function(data, textStatus){
                    //data可能是xmlDoc、jsonObj、html、text等等
                    this;  //调用本次ajax请求时传递的options参数
error：            要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。
                   ajax事件函数如下：
                   function(XMLHttpRequest, textStatus, errorThrown){
                      //通常情况下textStatus和errorThrown只有其中一个包含信息
                      this;   //调用本次ajax请求时传递的options参数
                   }
contentType：     要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为"application/x-www-form-urlencoded"。该默认值适合大多数应用场合。
dataFilter：      要求为Function类型的参数，给Ajax返回的原始数据进行预处理的函数。
                    提供data和type两个参数。data是Ajax返回的原始数据，type是调用jQuery.ajax时提供的
                    dataType参数。函数返回的值将由jQuery进一步处理。
                    function(data, type){
                        //返回处理后的数据
                        return data;
                    }
global：         要求为Boolean类型的参数，默认为true。表示是否触发全局ajax事件。设置为false将不会触发全局ajax事件，ajaxStart或ajaxStop可用于控制各种ajax事件。
ifModified：     要求为Boolean类型的参数，默认为false。仅在服务器数据改变时获取新数据。服务器数据改变判断的依据是Last-Modified头信息。默认值是false，即忽略头信息。
jsonp：          要求为String类型的参数，在一个jsonp请求中重写回调函数的名字。
                 该值用来替代在"callback=?"这种GET或POST请求中URL参数里的"callback"部分，例如{jsonp:'onJsonPLoad'}会导致将"onJsonPLoad=?"传给服务器。
username：       要求为String类型的参数，用于响应HTTP访问认证请求的用户名。
password：       要求为String类型的参数，用于响应HTTP访问认证请求的密码。
processData：    要求为Boolean类型的参数，默认为true。默认情况下，发送的数据将被转换为对象（从技术角度来讲并非字符串）以配合默认内容类型"application/x-www-form-urlencoded"。如果要发送DOM
                 树信息或者其他不希望转换的信息，请设置为false。
scriptCharset：  要求为String类型的参数，只有当请求时dataType为"jsonp"或者"script"，并且type是GET时才会用于强制修改字符集(charset)。通常在本地和远程的内容编码不同时使用。

案例代码：
$(function(){
    $('#send').click(function(){
         $.ajax({
             type: "GET",
             url: "test.json",
             data: {username:$("#username").val(), content:$("#content").val()},
             dataType: "json",
             success: function(data){
                         $('#resText').empty();   //清空resText里面的所有内容
                         var html = '';
                         $.each(data, function(commentIndex, comment){
                               html += '<div class="comment"><h6>' + comment['username']
                                         + ':</h6><p class="para"' + comment['content']
                                         + '</p></div>';
                         });
                         $('#resText').html(html);
                      }
         });
    });
});

如果是chrome还可以数设置：context.Response.AddHeader("Access-Control-Allow-Origin", "*");来达到跨域！
/*---------------弃用的API------------------*/
1.7 deprecated 弃用的
.die()
jQuery.sub()
.live()
.selector


1.8 deprecated 弃用的
.error()
.load()         当所有子元素已经被完全加载完成时，load事件被发送到这个元素
                废弃原因： 开发者们在试图使用 .load() 事件来解决一个共通的挑战，那就是：当一张图片（或一组图片）被完全加载完之后，执行一个函数。以下是一些相关的注意事项：
                          它在跨浏览器下始终是不可靠
                          如果被设置图片的src和之前的src相同，在WebKit中，该事件不能正常触发
                          不能正常的在DOM树上冒泡
                          如果图片已经在浏览器的缓存中，将停止触发
.size()         用length属性替代
.toggle(function1,function2)         每次点击后，fun1 fun2交替触发，在动画中也有同名toggle(time)用来切换show()和hide();
.unload(function(){})                当用户离开这个页面时，就会触发window元素上的unload事件。这意味着很多情况会触发这个事件。
                                     用户可以点击一个链接，离开页面，或在地址栏输入一个新的URL。前进和后退按钮会触发该事件。
                                     关闭浏览器窗口，将导致该事件被触发。即使重新加载页面首先会创建一个unload事件。
                                     任何 unload事件处理程序必须绑定到 window 对象:
                                     $(window).unload(function() {
                                       alert('Handler for .unload() called.');
                                     });

/*------------------------------------------------------------------------------------------------------------------*/
/*------------------------------------JavaScript部分:Javascript是一门解释型语言！--------------------------------------*/
/*------------------------------------------------------------------------------------------------------------------*/
载入js的方式：同步、异步、延迟加载
同步：即按照载入js文件的顺序执行，阻塞页面渲染
异步：<script src="x.js" async/async="true"></script>
延迟：<script src="x.js" defer></script>

$(function(){});//该程序是在页面仅仅加载完DOM树后即可执行，而不必非要等到加载完视频，音频，图片flash等资源
jQuery.noConflict();//让$符号给其他库使用，eg:var jq=$.noConflict();将$符号改为jq去用jQuery
(function($){})(jQuery);
等价于：
var fn = function($){....};
fn(jQuery);


引入方式：常用是<script src="///.js文件"></script>

<body>
    <noscript>作用是当浏览器不支持脚本的时候作为文本输出提示信息</noscript>
</body>

//该程序在页面全部加载完成后（包括图片、视频、音频等）再执行
window.onload=function()
{
    //在这里执行操作
}

/--------------第3章 类型、值和变量--------------/
基本类型：数字，字符串，布尔值，null(空)，undefined(undefined)；其中null和undefined都不可以调用任何方法；
对象类型：Object，函数，Date，正则(RegExp)，Error，数组等；特点是：[属性：值]的形式

【数值类型】
在js中，只有浮点数，当然我们可以定义一个整型量，或者浮点型 .3  1.2
+ - * / %(求余运算)
正无穷大：Infinity
负无穷大：-Infinity   注意：正负无穷大是在大于最大值，小于最小值，或者被0除会出现
NaN：非数             注意：0/0 | 正无穷大/正无穷大 | 给负数做开方 | 或者无法将某个变量转换为数值时才会得到，
                     NaN和任何数都不相等,包括自己，所以不能够用x==NaN,而是用x!=NaN；而且判断x是否是“非数” 可以通过isNaN(x)
Math.round(.6)          ：=>1.0   四舍五入
Math.cell(.6)           ：=>1.0   向上求整数
Math.floor(.6)          ：=>0.0   向下求整数
Math.abs(-6)            ：=>6     求绝对值
Math.random()           :生成一个大于0小于1.0的随机数
toFixed(n)              :（n:0~20）四舍五入为指定小数点后的n位有效数字,eg:12.37 toFixed(1)  为12.4
注意：所有的编程语言中，浮点型都无法精确表示像0.1那样的小数，比如0.3-0.2并不等于0.2-0.1

【Date类型】
new Date()               创建当前的日期
new Date(某个日期)        创建某个日期
date.getFullYear()       返回当前的年（2015）
date.getMonth()          从0开始的月份
date.getDate()           从1开始的天数
date.getDay()            0代表周日，1代表周1，以此类推，6代表周6
所有的Date对象方法
Date()    返回当日的日期和时间。
getDate()    从 Date 对象返回一个月中的某一天 (1 ~ 31)。
getDay()    从 Date 对象返回一周中的某一天 (0 ~ 6)。
getMonth()    从 Date 对象返回月份 (0 ~ 11)。
getFullYear()    从 Date 对象以四位数字返回年份。
getHours()    返回 Date 对象的小时 (0 ~ 23)。
getMinutes()    返回 Date 对象的分钟 (0 ~ 59)。
getSeconds()    返回 Date 对象的秒数 (0 ~ 59)。
getMilliseconds()    返回 Date 对象的毫秒(0 ~ 999)。
getTime()    返回 1970 年 1 月 1 日至今的毫秒数。
getTimezoneOffset()    返回本地时间与格林威治标准时间 (GMT) 的分钟差。
getUTCDate()    根据世界时从 Date 对象返回月中的一天 (1 ~ 31)。
getUTCDay()    根据世界时从 Date 对象返回周中的一天 (0 ~ 6)。
getUTCMonth()    根据世界时从 Date 对象返回月份 (0 ~ 11)。
getUTCFullYear()    根据世界时从 Date 对象返回四位数的年份。
getUTCHours()    根据世界时返回 Date 对象的小时 (0 ~ 23)。
getUTCMinutes()    根据世界时返回 Date 对象的分钟 (0 ~ 59)。
getUTCSeconds()    根据世界时返回 Date 对象的秒钟 (0 ~ 59)。
getUTCMilliseconds()    根据世界时返回 Date 对象的毫秒(0 ~ 999)。
parse()    返回1970年1月1日午夜到指定日期（字符串）的毫秒数。
setDate()    设置 Date 对象中月的某一天 (1 ~ 31)。
setMonth()    设置 Date 对象中月份 (0 ~ 11)。
setFullYear()    设置 Date 对象中的年份（四位数字）。
setHours()    设置 Date 对象中的小时 (0 ~ 23)。
setMinutes()    设置 Date 对象中的分钟 (0 ~ 59)。
setSeconds()    设置 Date 对象中的秒钟 (0 ~ 59)。
setMilliseconds()    设置 Date 对象中的毫秒 (0 ~ 999)。
setTime()    以毫秒设置 Date 对象。
setUTCDate()    根据世界时设置 Date 对象中月份的一天 (1 ~ 31)。
setUTCMonth()    根据世界时设置 Date 对象中的月份 (0 ~ 11)。
setUTCFullYear()    根据世界时设置 Date 对象中的年份（四位数字）。
setUTCHours()    根据世界时设置 Date 对象中的小时 (0 ~ 23)。
setUTCMinutes()    根据世界时设置 Date 对象中的分钟 (0 ~ 59)。
setUTCSeconds()    根据世界时设置 Date 对象中的秒钟 (0 ~ 59)。
setUTCMilliseconds()    根据世界时设置 Date 对象中的毫秒 (0 ~ 999)。
toSource()    返回该对象的源代码。
toString()    把 Date 对象转换为字符串。
toTimeString()    把 Date 对象的时间部分转换为字符串。
toDateString()    把 Date 对象的日期部分转换为字符串。
toGMTString()    请使用 toUTCString() 方法代替。
toUTCString()    根据世界时，把 Date 对象转换为字符串。
toLocaleString()    根据本地时间格式，把 Date 对象转换为字符串。
toLocaleTimeString()    根据本地时间格式，把 Date 对象的时间部分转换为字符串。
toLocaleDateString()    根据本地时间格式，把 Date 对象的日期部分转换为字符串。
UTC()    根据世界时返回 1970 年 1 月 1 日 到指定日期的毫秒数。
valueOf()    返回 Date 对象的原始值。

【String类型——因为字符串的不可变，方法 返回的都是新的字符串】
注意：字符串不是对象，但是可以调用方法，原因是在调用方法时候，JavaScript会把字符串转换为new String("字符串")对象

charAt(i)               [根据数字找字母]——返回传递给此方法的索引处的字符 eg:"lihonglei".charAt(1)=>返回了第2个字符
indexOf(str,num)        [根据字母找数字]返回str字符串第一次出现的位置，如果没有找到返回-1,如果有num则，起始位置从num开始(num从0开始计数)
slice(开始,结束)         截取并返回新的字符串-str.slice(start,last),[strar,last)包含开始，不包含结束，而且这个方法支持负数，即从后向前数-X个字符，如果结束没写，那么就从开始到最后全部截取
split(分割符，[返回数组的最大长度])   ""分隔符将会把字符串的每一个字符都拆分，并返回由字符串组成的数组，如果指定第二个参数，则会限制数组的长度
                                    eg：var str="How are you doing today?"
                                       document.write(str.split(" ",3))——>["How","are","you"]而第四个字符串"today?"是第四个元素，就不会被收集
replace("匹配的字符串/正则","替换的字符串")    如果被替换的是字符串：则只替换第一个匹配的，如果是正则表达式则替换全部匹配的
toUpperCase()           把小写字符变为大写字符，并返回新的字符;
toLowerCase()           把大写字符变为小写字符，并返回新的字符;
concat(e1,e2……)         把e1、e2添加到调用者上，并且返回新的字符串/数组，eg:"lihonglei".concat("——nice")=》lihonglei——nice（新的，不是在原来的基础上改的），[1,2].concat(4,5)=>[1,2,4,5]也是新的数组
RegExpObject.test(string)     test() 方法用于检测一个字符串是否匹配某个模式.检测string是否匹配了前面的正则表达式
stringObject.match(searchvalue|regexp)   只要匹配的都以数组-字符串形式返回
eg："1 plus 2 444 equal 33".match(/^\d/g)——全局 匹配开头是数字的字符串;返回：["1"]
    "1 plus 2 444 equal 33".match(/\d*/g);——全局 匹配“至少出现0次或者一次的数字字符串”
    ["1", "", "", "", "", "", "", "2", "", "444", "", "", "", "", "", "", "", "33", ""]
    "1 plus 2 444 equal 33".match(/\d+/g);
    ["1", "2", "444", "33"]

转换为字符串：String(要转换的参数)，一般来说：null，undefined无法调用方法包括toString()，所以可以利用String(null)将null转换为字符串


字符串方法例子
var str="hello,lihonglei";

        //str.charAt(index);返回指定位置的字符；
        var x=str.charAt(4);
        document.writeln("hello,lihonglei的第5个字符是："+x+"<br>");
        var y=str.charAt(str.length-1);
        document.writeln("hello,lihonglei的第最后一个字符是："+y+"<br>");



        //str.slice(start,last),[strar,last)包含开始，不包含结束，而且这个方法支持负数，即从后向前数-X个字符
        var z=str.slice(0,5);
        var z1=str.slice(-3);
        document.writeln("hello,lihonglei的前5个字符是："+z+",从后面数3个是："+z1+"<br>");



        //str.indexOf("xxx"),返回xxx字符串第一次出现的起始位置，若没有返回-1
        var a=str.indexOf("li");
        document.writeln("第一次出现li字符的地方是："+a+"<br>");



        //str.split("");将字符串的每一个字符都拆分（包括空格，标点等），再组成数组。str.split(",");用，分割字符串成数组,返回的数组中的字串不包括"传入的参数" 自身。；
        var array=str.split("l");
        document.writeln("用 ， 分割字符串得到的数组为："+array+"<br>");



        //str.replace("a","b")，a被替换为b，注意如果是第一个参数是字符串，那么只会被替换第一个，后面的不会替换，若想全部替换则用正则表达式！/g表示全部
        var b=str.replace(/l/g,"L");
        document.writeln("用L替换l："+b+"<br>");
        document.writeln("转换为大写"+str.toUpperCase()+"<br>");
        document.writeln("最终的str是："+str);
        var ss="a";
        alert(typeof(new String("a")));//Object
        alert(typeof(ss));//String
        alert(ss===new String("a"));//===false，==true



【boolean类型】
常用的6个false假值
undefined null 0 -0 NaN ""
undefined 和 null基本是相等的，但是用“===”会不相等 ,undefined是全局变量，null是关键字;===是特指类型也是相等的，值也是相等的，==只是值相近似


【类型转换】
num.toFixed(index)      保留index位有效数字index>=0,并且四舍五入
parseInt("字符串")      全局函数-将字符串中的数字转换为整型——全局函数，直接使用，eg:13.53->13，字符串开头若为字母，值为NaN
parseFloat("字符串")    全局函数-将字符串中的数字转换为浮点型——全局函数，直接调用，字符串开头若为字母，值为NaN
Number(X)               可以使：数值，字符串，boolean，等，true-1，false-0，null-0；
所有的对象都可以转换为boolean值：true，哪怕是：new Boolean(false)  也是true

in           var point={x:1,y:2}   "x" in point =>true   此运算符作用是判断左侧的字符串是否是右侧对象的属性
instanceof   判断左侧的操作数（对象）是否是右侧类的实例，如果是，返回true 否则false

             短路用法：就是&& ||，谁最终决定了整个值得走向，谁就会被返回
&&           特殊用法：短路：A && B 当A为false时(那么无论B是真还是假其最终都是false)，只计算A的值，并且返回A值，当A为真时，不论B是真是假，都返回B的值
             常常会这么写：(a==b) && 【另外的执行体】  等价于  if(a==b){另外的执行体}
||           同样，A||B||C  如果A为真，则返回A值，反之判断B是否为真，以此类推，如果AB都为假，则肯定要返回最后一个C值

typeof X     undefined=>"undefined"
             null=>"object"
             true/false=>"boolean"
             数字/NaN=>"number"
             字符串=>"string"即：typeof("a");和typeof(new String("a"));
             函数=>"function"
             内置对象[Array,Date,RegExp,](非函数|数组)=>"object"
【RegExp正则】
构造器：       new RegExp(pattern, attributes);   pattern:字符串，指定正则表达式/字符串常量，attribute:"g"-全局，替换全部(不是仅仅匹配开头/结尾就结束，整个字符串只要合适就匹配)、"i"-区分大小写 和 "m"-多行匹配，
              eg: var filterReg=new RegExp("^\\s+|\\s+$","g");noSpaceText=textValue.replace(filterReg,"");
                  匹配字符串的开头和结尾，若有空格，则替换为""
另外一种写法：replace(/^\s+|\s+$/g,"");这里不用\\s转义字符，全局定义的话，增加g

【变量的“声明提前”和函数作用域】
1、局部变量声明提前
var scope="global";
function check（）
{
    console.log(scope);//输出的是："undefined"
    var scope="local";
    console.log(scope);//输出的是："local"
}
上述代码等价于：因为局部变量只有在执行到var时候，才能真正的赋值即
var scope="global";
function check（）
{
    var scope;//肯定是undefined
    console.log(scope);//输出的是："undefined"
    scope="local";
    console.log(scope);//输出的是："local"
}
2、函数作用域
在JavaScript中只有函数作用域，没有块级别的作用域！即在函数内定义的变量在整个函数内都可见，而且正因为上面这个原因才有“声明提前”这个说法；比如在if语句定义i，i在函数内第一行访问是可以的，这个Java完全不同
注意：声明提前不代表赋值也会提前！！！

3、作用域链(有专门的一篇笔记)
demo:其实作用域链，就是一个变量所依附的对象链，对象(函数其实也可以看做是对象).变量
name="lwy";
function t(){
    var name="tlwy";
    function ss(){
        console.log(name);
    }
    ss();
}
t();
在这个函数中即t()中，有一个作用域链【---ss----t-----window】，即定义一个函数时（如果内部没有嵌套函数）其实就已经保存了一个作用域链——它的作用域链上至少有两个：一个是它本身构成的对象，下面是全局window
而在查找变量时就会按照本身然后依次向下查找，就是因为这个全局变量的查找速度很慢


/--------------第5章 语句--------------/

[function]
函数声明：function name(args1,args2,……){语句}   注意：这个和 函数定义语句var name=function(){}是不同的，后者在调用时必须在声明后面否则报错，而用function name定义的可以提前调用!

条件语句：
if()
{
  XX
}
else if()
{
  XX
}
……
else
{

}

switch(n(表达式))
{
    case 1(表达式值):
    若干语句;
    break;
    default:
    最后的语句;
    break;
}

循环语句：
while循环:
var count =1;
while(count<=10){console.log(count);count++}

for循环：
for(var i=0;i<=10;i++){执行语句}

                                                                    for in循环===$.each(dom/array,function(index,value){});
                                                                    var json={"x":1,"y":2,"z":3};  json=[1,2,3]
                                                                    for(var p in json)
                                                                    {
                                                                        console.log(json[p]);
                                                                    }
                                                                    输出1 2 3

break语句：跳出本次以及后面的循环
for(var i=0;i<=10;i++){if(i==5){break;}}
continue语句: 跳出本次循环，进入下次循环



/--------------第6章 对象--------------/
对象：是无序的名/值对组成的集合，它的常见用法:创建，设置，查找，删除，检测，枚举它的属性。“属性名字一定是一个字符串”：属性值是任意类型
(1)对象中不能够存在同名的属性名
属性的特性：可写【是否可以设置该属性值】，可枚举【是否可以通过for/in循环遍历返回该属性】，可配置【是否可删除或者修改该属性】

对象分为3种：内置对象——函数、日期、正则、数组
            宿主对象——javascript运行所在的浏览器对象：window对象
            自定义对象，比如自己new的
属性分为2中：自有属性
            继承自原型的属性

创建对象：1、对象直接量：JSON——{"name":"lihonglei","salary":15000}，每次运行都会生成一个对象，如果放在循环里会产生很多的对象，从目前来看，确实没有把这个json放在循环里声明过。
           对象直接量的原型是：Object.prototype
         2、new方式：new Date();new RegExp();（开销最大）
         3、原型对象创建对象(扩展自己)：原型对象：就是一个对象的始祖对象；类名.prototype指向类的原型对象；比如 new Date()得到一个日期对象，这个日期的原型对象就是Date.prototype，
            得到的是最“根”的始祖对象，如果以后要扩展Date类的方法，属性，就可以如此扩展：
            比如：类名.prototype.扩展的属性/方法，如果写成类名.prototype={属性/方法}的话会将原来的prototype覆盖。

         4、var o=Object.create(任意对象，扩展);第一个参数对象将成为o的原型对象，eg：var o=Object.create({"a":1,"b":2},扩展);此时o的原型就是{"a":1,"b":2}
            var x=Object.create(Car.prototype,可选参数)，x继承了Car的原型，并扩展了“可选参数”，实际上create()方法就是创建了一个继承自某个父类的对象并扩展了相应的方法
            书中模拟此方法的函数：
            function inherit(p)
            {
                if(p===null){throw TypeError()}//如果传入的是null抛出异常
                if(Object.create)
                {
                    return Object.create(p);//如果有此方法，直接使用
                }
                else
                {
                    var t=typeof p;
                    if(t!=="Object" && t!=="function")
                    {
                        throw TypeError();
                    }
                    else
                    {
                        function f(){};
                        f.prototype=p;
                        return new f();
                    }
                }
            }

扩展的属性：1、数据属性   2、存取器属性
1、数据属性包含4个特性：value | writable | enumerable | configurable
1、存取器属性包含4个特性：set,get,enumerable,configurable
demo1：
//创建一个对象的直接量obj(实际就是JSON的创建方式)
    var obj =
    {
        a:function(){
            console.log(100)
        },
        b:function(){
            console.log(200)
        },
        c:function(){
            console.log(300)
        }
    }
    var newObj = {};
    //利用Object.create(原型，参数[可选])创建了newObj对象，newObj继承了obj,并扩展了两个属性t1,bar;
    newObj = Object.create(obj,{
        t1:{//数据属性
            value:'t1的值',//t1属性的值为yupeng
            writable:true//writable特性：true，即可写
        },
        bar: {//存取器属性
            configurable: false,//不可配置,但是却设置了setter和getter方法，即依旧可以“写入”和读取
            get: function() { return bar; },
            set: function(value) { bar=value ;}
             }

    })
    newObj.a();
    console.log(newObj.t1);//输出t1的原始值
    newObj.t1='修改后的t1的值'//重写t1值
    console.log(newObj.t1);

    newObj.bar="bar的值";//setter
    console.log(newObj.bar)//getter

function Car (desc) {
    this.desc = desc;
    this.color = "red";
}
//JSON写法，可以扩展Car多个属性(函数)——这里在李刚的书中有提到：就是当你想扩展某个自己写的类的时候，就用这个方式扩展属性、方法，还能够防治闭包
Car.prototype = {
    //另外一种写法  Car.prototype.getInfo=function(){……}
    getInfo: function() {
      return 'A ' + this.color + ' ' + this.desc + '.';
    }
};
//instantiate object using the constructor function
var car =  Object.create(Car.prototype);
car.color = "blue";
alert(car.getInfo());


检测属性：
in                         用来判断某属性是否在对象中  eg:var o={"x":1};  "x" in o;
hasOwnProperty("属性名")   用来判断某对象是否有自有属性 eg:o.hasOwnProperty("x")=>true   o.hasOwnProperty("toString")=>false "toString"不是自有属性
!==                        和in相同，eg:o.x!==undefined =>true(o中有x属性)  注意：这个方式有局限性，如果属性的值就是undefined那么o.x!==undefined为false，判断反而错误，所以最好用in
for(in)

属性访问错误：
对象.属性/对象[属性]时，如果没有这个属性，则返回undefined
所以若对象不存在.其他属性/方法，则必然报错，因为，undefined无法调用属性

序列化：
JSON.Stringify(json对象)                                                    JSON---->JSON结构字符串
JSON.parse("严格要求的json形式的字符串") /$.parseJSON(string_json)           JSON结构字符串---->JSON

获取对象的类属性：和typeof()不同，我想获得的是：如果有一个数组对象array,我希望他能够返回"Array"这个字符串，如果用typeof array得到的是"object"
function classof(p)
{
    if(o===null) return "Null";
    if(o===undefined) return "Undefined";
    return Object.prototype.toString.call(o).slice(8,-1);
    //最后一行代码意义是：如果直接调用对象的prototype.toString()不会得到想要的字符串，因为每一个类都会对toString()方法进行改写，所以必须调用最根的toString 方法，得到"[object,Array]"，然后截取
}


/--------------第7章 数组--------------/
数组的某个元素的索引值 < 数组.length值
var a=[1,2,3,4,5]    a.length=2  a此时为：[1,2] 这里是一个技巧，即快速删除数组元素
创建数组：var array=new Array(10);或者：new Array(1,2,3,4,"str"); 或者json方式：var a=[1,2,3,4,5]


push(e1,e2……)          在数组末尾添加元素，返回新长度
pop()                  删除最后一个元素，返回删除的元素的值
unshift(e1,e2……)       在数组头部添加元素，返回新长度
shift()                删除第一个元素，返回删除的元素的值
字符串转数组：split(分割方式，保留几个数组元素)
数组转换为字符串：join(连接方式|不写)      将数组的每一个元素转换为字符串然后连接在一起；并返回其字符串；不写参数默认分割用",",指定的，用指定字符分割
                       eg:[1,2,3].join()=>"1,2,3"   join(" ")=>"1 2 3"
reverse()              将调用的数组内部的元素进行逆序排列；注意：这里是改变了原来数组，不产生新数组
sort()???
slice(start,|end)      [start,end) 截取数组，并返回新的数组,第二个参数可以不写，即从开始到最后，而且可以使负值，-1表示倒数第一个
splice(start,num,e1,e2……)   这个方法会在删除的同时，插入数据
                            start:定义了起始位置,num:确定了删除包含起始位置的几个元素，e1，e2……确定了从起始位置插入的数据，
                            返回：删除的元素构成的数组，原来的数组变为修改后的数组
                            eg:a[1,2,3,4,5,6,7,8]
                               a.splice(2,2)=>返回：[3,4] a变为[1,2,5,6,7,8]
                               a.splice(2,2,"a")=>返回：[5,6] a变为[1,2,"a",7,8]
forEach(function(value,index,数组本身){})      遍历数组,数组.forEach(回调函数)，这个回调函数可以改变原数组的值.注意：此函数无法终止（像for循环：有break/continue）除非用try语句抛出异常
                                              需要注意：这里可以穿3个参数：数组值，下标，数组本身；但是，常常是只用第一个value

由于IE没有forEach;
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function(callback, thisArg) {
        var T, k;
        if (this == null) {
            throw new TypeError(" this is null or not defined");
        }
        var O = Object(this);
        var len = O.length >>> 0; // Hack to convert O.length to a UInt32
        if ({}.toString.call(callback) != "[object Function]") {
            throw new TypeError(callback + " is not a function");
        }
        if (thisArg) {
            T = thisArg;
        }
        k = 0;
        while (k < len) {
            var kValue;
            if (k in O) {
                kValue = O[k];
                callback.call(T, kValue, k, O);
            }
            k++;
        }
    };
}


map(function(value){return ……})       对每次返回的数据放入新的数组中，并最终返回一个新的数组
filter(function(value){return boolean})         过滤数组，value经过运算后如果返回true，则这个数组元素将放入新的数组，否则不放入（注意：此方法会过滤掉稀疏数组的缺少的元素）
every(function(value){return boolean})          对所有元素进行判定，只有当所有元素都满足时，返回true
some(function(value){return boolean})           同上，只不过它是“只要有一个”满足函数整体即返回true
注意：对于上面的两个方法，every只要有一个是false则后面的就不会遍历，some则是只要有一个是true就会停止遍历

indexOf(value，|start可选)
lastIndexOf(value,|start可选)             和string类型的数据一样，判断数组中是否有某value，若有返回其位置，若无返回-1，第二个参数可选：指定查询的起始位置
isArray()                                 判断某对象是否是数组类型

/--------------第8章 函数--------------/
一、创建函数：
    1、函数表达式：即匿名函数

    例如：
    alert(typeof function(){});// "function"
    alert(typeof function(x,y){return x+y;});// "function"
    alert(typeof new Function("x","y","return x*y;"))// "function"
    alert(typeof function(){});// "function" alert(typeof function(x,y){return x+y;});// "function" alert(typeof new Function("x","y","return x*y;"))// "function"

    匿名函数调用方式1：
            f();//如果写在这里调用——无法调用，f变量确实提前了，但是赋给f的值并没有提前（这里就是前面的JavaScript中的声明提前机制）
            var f=function(){alert("提前问题");}
    匿名函数调用方式2：
            (function(x,y){alert(x+y);})(1,2);这种方式函数会直接运行！
            (function(x,y){alert(1)})(1,2)应该是与 a=function(){alert(1)}()等价，不能连a=都去掉。


    2、函数声明：function f();//但是通过函数声明的方式创建的函数，就可以提前调用（若如此定义，则处处可用）

二、调用的四种方式：
                1、作为函数：f()
                2、作为方法：对象.f()=> var object={f:function(){}}
                3、**new构造器调用**
                var Person=function(name,age)//function Person(name,age){}
                    {
                        this.name=name;//这里和java不同，需要提前定义类中的属性，name，age
                        this.age=age;
                        alert("a");//new对象后运行了，
                        //this.getInfo();如果加上这句，那么只要new一个Person对象(或者Person("lhl",27)也会运行)，就会直接运行这个函数，而不用new对象再调用getInfo()方法，也就是说：new一次就会
                        运行类中所有代码！
                        //而且还记得：不要把方法写在方法内，而是用prototype扩展
                    }
                4、对象.方法名.call(调用对象，参数) apply();
                5、(function(x,y){return x+y})(1,2); 其实(function(x,y){return x+y})返回的是一个变量，是对函数的引用，所以：函数引用(1,2),就会执行函数，就像var x=function(){};x()，这里x就是引用

三、函数参数：
                形参：定义函数时所写的参数
                实参：真正调用函数时传入的参数
                arguments         函数的内置对象：获取传入的实参的类数组对象(不是真正的数组)：arguments.length


四、函数的变量：
                局部变量：在函数中定义：var x;
                实例属性：this.x;
                类属性：函数名字.x;
五、函数的属性
                函数名.length     返回函数定义时的参数的个数
                函数名.prototype  返回原型对象

闭包举例：
var scope="global";
function checkScope()
{
    console.log("闭包例子：");
    var scope="local";
    function f(){return scope};
    return f;//
}
    console.log(checkScope()());

参数过多问题：
function x(x,y,z)
{
   if(arguments.length<3){抛出异常}
}
这里有一个麻烦的现象：如果参数很多，我们就不得不查文档，看哪个参数对应哪个
解决方式：传入一个对象，这个对象实际json形式{"参数1":"值1"……}
function(args){args.参数1……}这样就不用记忆参数的具体位置了

call(调用者对象)             eg  f.call(x);等价于：x.f();
apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。
如 func.call(func1,var1,var2,var3)对应的apply写法为：func.apply(func1,[var1,var2,var3])
例子：Array.prototype.map.call(docuemnt.getElementsByTagName("p"),function(e){return e.innerHtml;});


var f=function(x,y){return x+y} 和 function f(x,y){return x+y}并没有根本区别

作为值的函数(把函数名字当做变量传入)：
函数当做是一个值：var f1=f;f(1,2)和f1(1,2)没有区别
例子：function add(x,y){return x+y}
function operate(functionName,value1,value2)
{
    return functionName(value1,value2);
}
operate(add,1,2);

/--------------第9章 类和模块--------------/
一、原型和构造函数
1、原型：所有的对象都一定从一个原型对象来继承所有的方法和属性，而且原型对象是类的唯一标识，所以两个对象只有继承自同一个原型对象才能说这两个对象时同一种类型；
        对于函数(类)：原型：类名/函数名.prototype
        对于对象直接量：它的原型是Object.prototype
        普通对象(new出来的)：对象.__proto__，但最好别用

        例子：F.prototype={重写原型对象}，即覆盖了原来的原型对象；【在java类中如果没有写构造器，会有一个默认的，如果写了自定义的构造器，一般还要写一个默认的以防止覆盖】
        另外一种扩展就是：F.prototype.扩展属性=function(){},这样就不会覆盖了
        ----------模拟java的继承机制-----------
        var Person = function () { };
        Person.prototype.Say = function () {
            alert("Person say");
        }
        Person.prototype.Salary = 50000;
        var Programmer = function () { };
        Programmer.prototype = new Person();
        Programmer.prototype.WriteCode = function () {
            alert("programmer writes code");
        };
        Programmer.prototype.Salary = 500;
        var p = new Programmer();
        p.Say();
        p.WriteCode();
        alert(p.Salary);　

2、constructor属性：每一个类一定有一个原型对象，这个原型对象必有一个不可枚举的属性：constructor,而这个属性的值：是函数对象
    对象||原型对象.constructor===F，也就是说：它的值是函数对象；类名.prototype指向原型对象，原型对象中通过这个constructor属性又会指向这个构造器
    如果重写了原型对象建议{constructor:F}，将这个加上，从而自定义一个属性，来实现反向引用
    eg:var F=function(){};
       var p=F.prototype;获取原型对象
       var c=p.constructor;获取函数对象(构造器)
       c===F
    从这段代码看出：原型对象有constructor属性，所以——>所有由F创建出来的对象必有此属性——>F.prototype.constructor===F，或者说f.constructor===F;
3、构造函数：用来初始化新对象的，它是类的外在表象，不论创建多少个F的对象，它的原型只有一个：F.prototype;

二、类和类型
instanceof：r instanceof R  其实判断的是：r对象是不是R.prototype对象继承过来的(r是不是R类的实例)
isPrototypeOf():x.isPrototypeOf(y)  判断x是不是y的原型对象
eg：
   var re = /^\s*/;
   // 这里定义一个正则表达式对象
   // 这里检查RegExp是不是re的原形链对象,返回true
   var bIsptt = RegExp.prototype.isPrototypeOf(re);

三、模拟java中的各种变量类型
java中：类方法/变量，实例方法/变量
javascript中：  之前说过：javascript中的函数是以值的形式出现的，函数名完全可以当做参数传入其它函数，也就是说，如果一个变量值是函数，那这个属性就是方法了，否则就是一般的“字段”
                1、构造函数的属性/方法：function F(){}，F是这个函数的类名，所以为F添加的属性/方法就是：类属性/方法；
                2、原型对象的属性/方法：因为只要创建对象一定继承自原型，所以它的属性/方法一定是：实例属性/实例方法（而且是所有实例对象都会继承的）
                3、实例对象的属性/方法：和原型对象的不同，每个实例都可以定义自己的属性/方法，并且只是属于自己（和java的继承出来的类的实例一样，鸟——鸵鸟）
所以定义一个类有3步:  （1）定义一个构造函数，并初始化实例属性；
                    （2）给构造函数的prototype属性定义实例方法；
                    （3）给构造函数定义类属性/方法

eg:function F(a,b)
    {
        this.a=a;
        this.b=b;
    }
    F.prototype.add=function(){return this.a+this.b}……//实例方法
    F.ZERO=0;//定义类字段
    F.get=function(){return this.a+this.b}……//类方法

三、鸭式辨型
就是不要考虑这个对象的类是什么，而要考虑这个对象能做什么：只要能像鸭子走路，游泳，嘎嘎叫的就是鸭子


/--------------第10章 正则表达式--------------/
1、创建的两种方式
(1)var reg=/s$/                 此时会自动生成一个RegExp对象直接量，就像{……}或者[]
(2)var reg=new RegExp("s$");    new一个对象
注意：在ECM3中，每次运行上面的代码生成的都是同一个对象，而在最新的ECM5中则恰好相反，不过这样反而符合开发规范！
eg:function getEcm(){
    var reg=/a/;
    reg.x="hello";
    return reg;
}
var r1=getEcm();
var r2=getEcm();
console.log(r1===r2);//如果是ECM3则返回true，ECM5则返回false
2、匹配类型(以下指示匹配  某一个，某一个，某一个！)
"数字/字符串"    自身
\o              NUL字符
\t              制表符
\n              换行符
\v              垂直制表符
\f              换页
\r              回车
[……]            one of them
[^……]           非one of them
\w              等价于[a-zA-Z0-9]
\W              等价于[^a-zA-Z0-9]
\d              数字  ，等价于[0-9]
\D              非数字，等价于[^0-9]
\s              空白符
\S              非空白

{n,m}           出现次数>=n 且 出现次数<=m
{n,}            出现次数>=n
{n}             出现次数=n
?               匹配前一项0或者1次，依旧是说：前面的那一项可有可无
+               匹配前一项1次或者多次
*               匹配前一项0次或者多次
3、模式类型（默认贪婪）
注意：使用*和？，因为他会导致什么都不匹配，匹配0个也是匹配：eg：/a*/ 它是匹配"bbbb"的，因为这个字符串匹配0个a

(1)贪婪模式[非全局]，即按照最多的情况匹配，如下第一行\w是匹配任意a-zA-Z0-9这其中之一，{1,3}指的是可以由上述字符组成1/2/3个，因为是贪婪，所以按照最多匹配3个原则，返回“abc”
"abcdefdfsfeffddd".match(/\w{1,3}/);   ["abc"]
"ab".match(/\w{1,3}/);   ["ab"]

(2)贪婪模式[全局]，即一个都不放过，正则表达式会逐个扫描字符串到最后(而且依旧以贪婪模式为第一要义，剩余的字符在匹配2的个数，依次类推)
"abcdefdfsfeffddd".match(/\w{1,3}/g);  ["abc", "def", "dfs", "fef", "fdd", "d"]

(3)非贪婪模式[非全局]，则匹配个数最少的，而且不会像全局模式全部扫描，只要找到即刻终止——第四行
"abcdefdfsfeffddd".match(/\w{1,3}?/);  ["a"]

(4)非贪婪模式[全局]，则匹配个数最少的，而且会扫描全部字符串，找出所有满足
"abcdefdfsfeffddd".match(/\w{1,3}?/g); ["a", "b", "c", "d", "e", "f", "d", "f", "s", "f", "e", "f", "f", "d", "d", "d"]

4、选择、分组、引用
a|b   ：匹配"a"或者"b"，注意：匹配的方式是从左到右，如果左侧已经匹配，则放弃右边的匹配
()    ：当做一个单元使用*+?，只对前面括号中的内容进行匹配。eg:/java(script)?/,可以匹配java或者Javascript,"script"可有可无

/--------------第14章 window对象——(window对象的方法或者属性都可以直接调用，不用写成window.方法/属性的形式)--------------/

var value1=setTimeout(函数名称/代码字符串,毫秒数X);经过毫秒数X执行一次代码;注：如果传递是函数名称，没有括号！
clearTimeout(value); 取消setTimeout的执行
var value2=setInterval(函数名称/代码字符串,毫秒数X);每次经过X毫秒执行一次代码
clearInterval(value2); 取消setInterval的执行

location                        window.location属性返回Location对象：这个对象有如下常用属性：

                                    eg:http://event.daoxila.com/HunChe/index.html?city=bj
                                    host:         "event.daoxila.com"
                                    hostname:     "event.daoxila.com"
                                    href:         "http://event.daoxila.com/HunChe/index.html?city=bj"
                                    origin:       "http://event.daoxila.com"
                                    pathname:     "/HunChe/index.html"
                                    port:         ""
                                    protocol:     "http:"
                                    search:       "?city=bj"
window.open("url","name","parameter")        url:打开的新窗口/选项卡页面地址；name：_blank/_parent/_self/_top/任意字符串;parameter:新窗口的参数(宽高等)，返回值是：打开的窗口的window对象
                                             eg:window.open('xxx','_blank','width=200,height=100')
window.close()                               关闭窗口
window.alert("显示的信息")
window.confirm("显示的信息")                 弹出：“确定”or“取消”，返回一个Boolean值
window.prompt("显示的信息")                  弹出：要求用户输入的字符串，并返回此字符串
eg:
do{
    var name=prompt("请输入您的名字");
    var rightName=confirm("请问这是您的名字吗？"+name);
}
while(!rightName){alert("名字错误");}

window.location——>Location对象

location.replace(url)                 在当前页面载入新的页面，当前页面被替换掉，与此同时会把当前文档从历史记录中清除，即无法返回到载入之前的页面
location.assign(url)                  在当前页面载入新的页面，当前页面被替换掉，但当前页面可以利用“后退”按钮返回到载入之前的页面
location.reload(true/false|不写)       F5 刷新当前页面，Boolean值：true：从缓存载入，不写|false从服务器重新获取

history.go(num)                      num正负值都可以，功能是：相当于点击向前或者后退按钮几次，若是0会刷新当前页面
history.back()                       相当于后退按钮
history.forward()                    相当于前进按钮

window.navigator——>Navigator对象？？？
辨别浏览器：是通过某浏览器是否支持某方法/功能，而不是通过浏览器版本号
navigator.appName    测试结果：IE11,chrome,firefox(Netscape)所以此方式不可用！尤其是IE11
navigator.userAgent  此方法可用，通过字符串特征值的判断


/--------------第15章 脚本化html文档--------------/

(1)获取节点dom
通过id(返回唯一dom)
        document.getElementById("id_value");返回的就是一个唯一节点

通过class特性值(返回dom数组，所以获取dom用[i])
        nodeList=document.getElementsByClassName("className_value");
        eg:document.getElementsByClassName("className1 className2……");

通过tag标签名称(返回dom数组，所以获取dom用[i])
        nodeList=document.getElementsByTagName("span/div/p")  不论返回几个，其返回值是一个数组，如果返回一个并获取必须用：document.getElementsByTagName("div")[0]
        eg:查找第一个p标签中的span标签：
        var p1=document.getElementsByTagName("p")[0];
        var span=p1.getElementsByTagName("span");
注意：对于IE8或者其更低的版本，是不支持此方法的，可以用querySelectorAll("选择器");其实这个和jquery一样
通过name
        这里的name常常就是表单中常用的name， nodeList=document.getElementsByName("name_value");返回值如果有多个则是类似数组的只读对象，即nodeList[0]可以选取第一个
        注意：如果name的值在整个文档中是唯一的（如果有多个也可以，但是不建议如此！），那么可以通过document.name_value获取DOM节点

遍历dom:
x=document.getElementsByTagName("p");

for (i=0;i<x.length;i++)
{
document.write(x[i].innerHTML);
document.write("<br />");
}


根据关系获取节点：
parentNode                   [属性]获取某节点的父节点，Document父节点为null
childNodes[n]                [属性]获取子节点   如果没有即为null
firstChild/lastChild         [属性]获取子节点中第一个和最后一个   如果没有即为null[firstChild===childNodes[0];X.childNodes[1]===X.firstChild.nextSibling]
nextSibling/previousSibling  [属性]该节点的兄弟节点中的下一个和上一个（对于<li>标签）
eg:document.childNodes[0].childNodes[1]===document.firstChild.firstChild.nextSibling返回的都是body  [document.childNodes[0]返回的->html<-document.firstChild]
   <html>
      <head>
        <title></title>
      </heat>
      <body></body>
   </html>

(2)创建dom节点
document.createElement("标签名")        eg：document.createElement("div")    [成本高]
要复制的节点.cloneNode(true/false)       Boolean值若为true:子节点也要复制，否则不用

(3)添加删除、替换dom节点(看这些方法都是在其父类节点进行操作的，而不是在要插入的节点去操作的)
fatherDom.appendChild(newDom)                在dom节点的子节点最后添加newDom
fatherDom.insertBefore(newDom,someNode)      在dom节点的子节点中的某someNode前面增加newDom
fatherDom.replaceChild(newDom,oldNode)      在dom节点的子节点中的某someNode前面增加newDom
fatherDom.removeChild(oldNode)              在某父节点删除某子节点
最后：document.write("任何代码/文本")  document.writeln("任何代码/文本")


(3)获取特性值，设置特性值
dom.特性名称(“类”为className而不是class)       eg:document.getElementById("img")[0].src,获取/设置;它可以返回数值和布尔类型
dom.getAttribute("特姓名")                   eg：document.getElementById("img")[0].getAttribute("src")，和上面的方式不同之处在于，这个方法他总会返回字符串，哪怕其值是布尔值，或者数值{比如input中的maxLength}
dom.setAttribute("特姓名","值")
dom.hasAttribute("特性值")
dom.removeAttribute("特性值")
eg：var form=document.forms[0]

(4)获取文本，设置文本
dom.innerHTML     返回节点的所有内容和jquery中的html()方法一样，如果内容是文本——返回文本，如果内部还有子标签则返回所有标签代码
dom.innerText     返回节点的所有内容和jquery中的text()方法一样，返回所有文本
dom.nodeValue     返回单个节点标签的纯文本
dom.value         返回input,textarea标签中的文本值

/--------------第16章 脚本化CSS--------------/
注意:比如：font-size:dom.style.font-size这是错误的写法！正确：fontSize,同理所有有连字符的css属性都要变为“驼峰式”写法！
dom.style.css属性名="字符串"   如果是数值要加上px等，如："100px"

/--------------第17章 事件处理--------------/
事件监听方式：
其实还有一种就是：直接写在html代码中
1、dom.onXXX=function(){}
2、dom.addEventListener("无on的事件",function(event){},默认是false);《addEventlistener只支持ie8以后的》
3、移除dom.removeEventListener("事件",外部function,boolean);
注意：这里的移除监听中的函数必须是外置函数：即如果直接写function(){js代码}是无效的，需要单独写函数，然后引入函数名
demo:
      var moveCheck=function(e)
      {
        e.preventDefault();
        e.stopPropagation();
      }
      document.removeEventListener("touchmove",moveCheck,false);

4、对于ie9以前的：只有两个参数：attachEvent("有on的事件",function(event){});detachEvent();

取消事件的默认操作的三种方式：
return false;
event.preventDefault();
event.returnValue=false;
eg:function cancelHandler(event)
{
    var event =event||window.event;(短路写法)
    if(event.preventDefault){event.preventDefault();}//标准技术
    if(event.returnValue){event.returnValue=false;}//用于IE
    return false;//对象属性注册的处理程序
}
event.stopPropagation()           阻止事件的传播：仅限IE9+/chrome/firefox可用
event.cancelBubble=true           阻止事件冒泡，IE9之前的浏览器可用

event.target 和 this区别：


鼠标事件：mouseover[鼠标进入时触发]|mouseenter[鼠标进入时触发，但不冒泡]；mouseout[鼠标离开时触发]|mouseleave[鼠标离开时触发，但不冒泡]
鼠标滚轮事件：mousewheel(IE6, IE7, IE8, Opera 10+, Safari 5+,常用)   DOMMouseScroll(Firefox 3.5+)
eg:x.addEventListener(mousewheel,function(event,){});

window.addEventListener("mousewheel",function(event){
            console.log(event.wheelDelta);
        });
keyup;
keydown;
keyCode;



/--------------第18章 Ajax--------------/
[首先：JavaScript文件是单线程执行的，即某一时刻只能执行某行代码，而浏览器是多线程的；对于异步的ajax请求则是：浏览器单独开一个线程；
即最少有两条线程：1是JavaScript文件内代码的执行；2是异步请求的线程；当请求回来后，插入事件队列让第一个线程逐个执行，这就是nodejs中的
事件驱动，异步执行]
Ajax

常用方法属性：
abort()                                 停止发送当前请求
getAllResponseHeaders()                 获取服务器返回的所有响应头
getAllResponseHeader("headerName")      获取某个响应头

open("GET/POST","url",若请求的服务器有密码则写上用户名和密码,boolean是否异步)   建立连接，最后一个参数一般为true
setRequestHeader("头名","头值")          在open后，send前写入，请求头
onreadystatechange                      状态发生变化时调用某函数
send(请求内容/null)                      发送请求内容

readyState===4                          0:xhr对象未完成初始化  1:xhr开始发送请求  2:对象的请求发送发成  3:对象开始读取服务器的响应  4：对象读取服务器响应结束
status===200
responseText                            响应服务器返回的响应文本
responseXML                             响应服务器返回的XML文档

var ajaxObject=new XMLHttpRequest();
若是在IE5/6版本
if(window.XMLHttpRequest===undefined)
{
    window.XMLHttpRequest=function()
    {
        try
        {
            return new ActiveXObject("Msxml2.XMLHTTP.6.0");//使用ActiveX的最新版本
            //李刚：new ActiveXObject("Msxml2.XMLHttp");
        }
        catch(e1)
        {
           try
           {
               return new ActiveXObject("Msxml2.XMLHTTP.3.0");//使用ActiveX的较旧的版本
               //李刚：new ActiveXObject("Microsoft.XMLHttp");最老版本
           }
           catch(e2)
           {
                throw new Error("不支持XMLHttpRequest");
           }
        }
    }
}
或者：
var xhr;
function createXMLHttpRequest()
{
    if(window.XMLHttpRequest)
    {
        xhr=new XMLHttpRequest();
    }
    else if(window.ActiveXObject)
    {
        try
        {
            xhr=new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch(e)
        {
            alert("您的浏览器不支持ajax！");
            return false;
        }
    }
}
请求步骤：
创建XMLHttpRequest对象
open(请求方式，url,true)    请求方式：POST GET
setRequestHeader(请求的头)
onreadystatechange
send(请求主体)         对于get请求方式：请求主题为null或者省略

响应部分：
1、状态码：
status/statusText属性       200    状态码        4
2、响应头
getResponseHeader()         响应头
3、响应文本
responseText                响应主体
4.
onreadystatechange          利用此属性监控readyState属性的变化


demo:
function ajax(url, fnSucc, fnFaild){
    //1.创建对象
    var oAjax = null;
    if(window.XMLHttpRequest){
        oAjax = new XMLHttpRequest();
    }else{
        oAjax = new ActiveXObject("Microsoft.XMLHTTP");
    }

    //2.连接服务器
    oAjax.open('GET', url, true);   //open(请求方式, url, 是否异步)

    其实这里还可以加上：请求头：oAjax.setRequsetHeader("ContentType","text/plain;charset=UTF-8");
    //3.对状态改变作出响应
    oAjax.onreadystatechange = function(){  //OnReadyStateChange事件
        if(oAjax.readyState == 4){  //4为完成
            if(oAjax.status == 200){    //200为成功
                fnSucc(oAjax.responseText)
            }else{
                if(fnFaild){
                    fnFaild();
                }
            }
        }
    };
    //4.发送请求
    oAjax.send(null);
}
demo：一定封装的ajax
ajax.js
var xhr;
function createXMLHttpRequest()
{
    此处为创建ajax对象
}
function processResponse(){
    if(xhr.readyState===4)
    {
        if(xhr.status===200){

        }
    }
}
function getPrice()
{
    createXMLHttpRequest();//获得ajax对象
    xhr.open("post",url,true);
    xhr.onreadystatechange=processResponse;
    xhr.send(null);

}
原生跨浏览器问题：
1.1、IE7及其以上版本中支持原生的 XHR 对象，因此可以直接用： var oAjax = new XMLHttpRequest();

1.2、IE6及其之前的版本中，XHR对象是通过MSXML库中的一个ActiveX对象实现的。有的书中细化了IE中此类对象的三种不同版本，即MSXML2.XMLHttp、MSXML2.XMLHttp.3.0 和 MSXML2.XMLHttp.6.0；
     个人感觉太麻烦，可以直接使用下面的语句创建： var oAjax=new ActiveXObject(’Microsoft.XMLHTTP’);

/--------------第20章 客户端存储--------------/
localStorage/sessionStorage
到目前为止：这两个对象还仅仅支持“字符串”类型额存储和读取，如果不是字符串的数据，最好是显示转换，再存储，如果直接存储也会被转换为String；取出数据应当注意到：取出数据时应当进行相应的类型转换

localStorage:     时间是永久的，除非删除：
                  范围是在文档源级别：文档源是由——协议+主机名+端口三者决定的；只有具有相同文档源的localStorage才能相互访问；
                  另一个限制是浏览器：不同浏览器无法相互访问

sessionStorage:   范围同上，还要加上：窗口级别，即关闭窗口（选项卡）数据就会消失，而且不同的选项卡也无法互相访问（哪怕是同一个页面，同一个脚本只是在不同选项卡中；但同一个选项卡有iframe是可以访问的）；

同源机制：相同协议+相同的主机名+相同的端口
eg：http://www.abc.com
    https://www.abc.com   不同协议
    http://www.abcd.com   不同主机名
    http://www.abc.com:8000  不同端口
以上四个域名无法共享localStorage/sessionStorage对象中的数据无法共享或者覆盖



localStorage.key/localStorage[key]  访问，也可以设置
setItem("key"，value)   localStorage.setItem("x","栗子");
getItem("key")
removeItem("key")     移除名字为key的 key-value对
clear()               全部删除
localStorage.key(i)   获取第i（从0开始）个key
eg：for(var i=0;i<localStorage.length;i++)
{
    var keyName=localStorage.key(i);
    var value=localStorage.getItem(keyName);
}
    localStorage.length:返回key-value对的个数
注意：如果存储的是数组，对象等这类可变的，则存储的只是副本，修改元对象不会改变存储在localStorage中的对象
navigator.cookieEnabled     判断浏览器是否支持cookie
navigator.online            判断浏览器是否在线
encodeURIComponent(String)           该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
                                     其他字符（比如 ：;/?:@&=+$,# 这些用于分隔 URI 组件的标点符号），都是由一个或多个十六进制的转义序列替换的。
encodeURI(string)                    该方法不会对 ASCII 字母和数字进行编码，也不会对这些 ASCII 标点符号进行编码： - _ . ! ~ * ' ( ) 。
                                     encodeURI() 函数是不会对如下进行转义的：;/?:@&=+$,#
decodeURIComponent(str)              和下面的方法一致，就是对字符串进行解码
decodeURI(str)

<script type="text/javascript">

var test1="http://www.w3school.com.cn/My first/"

document.write(encodeURIComponent(test1)+ "<br />")
document.write(decodeURIComponent(test1))

</script>

------Cookie-----
document.cookie=name+"=value;max-age=秒"
document.cookie="name="+value       设置一个cookie的值；key="name"  value="value值"，因为cookie不允许有；，空格等，所以保存的值应该用encodeURIComponent进行编码保存
                                    document.cookie="userId=828; userName=hulk"; 注意：每对之间由  "；空格"分割
                                    document.cookie="userId="+encodeURIComponent(值);
document.cookie                     获取所有的cookie，其值是一个字符串"key1=value1; key2=value2; ……"注意每一对之间是"分号+空格"
eg:  var cookieObj={};
     var allCookie=document.cookie();
     var list=allCookie.split("; ");//用分号和空格分割cookie字符串，返回数组["key1=value1","key2=value2"……]
     for(var i=0;i<list.length;i++)
     {
        var cookie=list[i];
        var cut=cookie.indexOf("=");
        var key=cookie.slice(0,cut);
        var value=cookie.slice(cut+1)
        value=decodeURIComponent(value);
        cookieObj[key]=value;
     }
     return cookieObj;//返回保存了cookie的对象



/*------------------------------HTML5——API--------------------------------*/

地理位置：
navigator.geolocation:返回一个对象，此对象可以调用如下方法：
navigator.geolocation.getCurrentPosition(回调函数)                 获取用户当前位置
var watch=navigator.geolocation.watchPosition()            获取当前位置，同时不断监视当前位置，一旦改变则调用指定的回调函数
navigator.geolocation.clearPosition(watch)                 停止监视用户位置
eg：
navigator.geolocation.getCurrentPosition(function(pos)
    {
        var x=pos.coords.latitude;//获取经度
        var y=pos.coords.longitude;//获取纬度
        alert("地理位置是：X："+x+",Y:"+y);
    }
);




历史记录管理：
location.hash               获取url的一个id，一种标识符
eg:http://www.iqiyi.com/zongyi/20110430/f47e601752207ca6.html#vfrm=13-0-0-1
location.hash->"vfrm=13-0-0-1"
如果设置其值：location.hash="lihonglei"->eg:http://www.iqiyi.com/zongyi/20110430/f47e601752207ca6.html#lihonglei而且原来“灰色”的后退按钮会变成可点击的。
其它请看原书




跨域消息传递：
targetWindow.postMessage(message,targetOrigin)
onMessage             事件的监听属性,比如：window.onMessage=function(event){}
                      event可以调用如下属性：
                        data：返回消息传递信息
                        origin:返回发送此消息的原域名
                        lastEventId:返回发送该消息的原id
                        source：返回发送该消息的窗口对象
eg:来自《疯狂》p465/466

原页面：
<script>
    var send=function()
    {
        疑惑：获取目标window对象一定要打开新窗口吗
        var targetWin=window.open("目标URL","_blank/_self","width=400,height=300");//获取目标窗口window对象
        targetWin.onload=function()//加载好打开的页面后触发“发送消息”
        {
            targetWin.postMessage("sourceMessage","目标url");
        }
        window.onmessage=function(event)
        {
            if(event.origin!=="目标域名")
            {
                return;
            }
            alert("此页面接收的信息是："event.data);
        }
    }
    触发send：
</script>
目标页面：
<script>
        window.onmessage=function(event)
        {
            if(event.origin!=="目标域名")
            {
                return;
            }
            alert("此页面接收的信息是："event.data);
            event.source.postMessage("回传原页面的信息",event.origin);
        }
</script>










多线程Worker：（注：多线程是可以双向通信的，不是非得只能线程文件发送数据给主体，主体也可以发送数据给线程）
var line=new Worker("javascriptUrl");
此对象可以有如下方法/属性：
onmessage事件监听：                     line.onmessage=function(event){event.data……}   获取数据
postMessage(data)                      line.postMessage(data);                        发送数据到某url
importScripts(urls)                    导入多个js文件：line.importScript("a.js","b.js","c.js")
sessionStorage/localStorage
Worker                                 创建嵌套线程(1、在前台界面创建嵌套线程；比如在onmessage中创建。2、在后台线程onmessage中再次创建线程)
XMLHttpRequest                         异步请求
location                               和window.location
通用的函数                              isNaN() parseInt等
eg：
a.js
<script>
    var b=new Worker("b.js");
    b.postMessage(data);//传递个b.js文件的数据
    b.onmessage=function(event)
    {
        data_b=event.data
    }
</script>

b.js
<script>
    onmessage=function(event)//b.js获得数据
    {
        var new_data=event.data;
        ………………处理数据
        postMessage(new_data);//再次发送给a.js
    }
</script>

但其实看李刚的书中第一个例子：主线程没有用postMessage(data)传递数据，new线程后仅仅是onmessage(event)来接收数据，而线程中用postMessage(data),上面的例子是双向通讯





webSocket：Websocket

          1.websocket是什么？
          WebSocket是为解决客户端与服务端实时通信而产生的技术。其本质是先通过HTTP/HTTPS协议进行握手后创建一个用于交换数据的TCP连接，
          此后服务端与客户端通过此TCP连接进行实时通信。

          2.websocket的优点
          以前我们实现推送技术，用的都是轮询，在特点的时间间隔有浏览器自动发出请求，将服务器的消息主动的拉回来，在这种情况下，我们需要不断的向服务器 发送请求，
          然而HTTP request 的header是非常长的，里面包含的数据可能只是一个很小的值，这样会占用很多的带宽和服务器资源。会占用大量的带宽和服务器资源。
          WebSocket API最伟大之处在于服务器和客户端可以在给定的时间范围内的任意时刻，相互推送信息。在建立连接之后，服务器可以主动传送数据给客户端。
          此外，服务器与客户端之间交换的标头信息很小。
          WebSocket并不限于以Ajax(或XHR)方式通信，因为Ajax技术需要客户端发起请求，而WebSocket服务器和客户端可以彼此相互推送信息；
方法：
webSocket("服务器url")             创建：var ws=new webSocket("url");
close();                          关闭socket
send(data)                        向服务器发送数据

监听事件：
onopen                           当建立连接时触发
onerror                          当建立连接出现错误时触发
onclose                          当连接关闭时触发
onmessage                        接收到服务器信息时触发：ws.onmessage=function(event){event.data}





/*--------------------------------Ajax(Asynchronous Javascript And XML)-----------------------------*/
特点：1异步：不用刷新全部，只是加载一部分   2服务器相应的就是数据，而不是页面！    3是应用，不是简单视图

使用步骤：1、创建ajax对象XMLHttpRequest    2、打开链接open     3、设置监听ajax对象状态改变onreadystatechange的函数    4、发送请求send()

常用方法：
abort()              终止当前请求
getAllResponseHeaders()         返回响应头的名称和值的单个字符串
getResponseHeader(name)         返回响应头指定名称的值
open(method,url,是否异步,username,password)
send(data/null)                 其实一般不会发送，即send(null),如果要发送数据（url?name=lihonglei&age=18）一般会放在url的尾部！

eg:chat.html
<script>
     //创建ajax对象
    var XMLHttpReq;
    function createXMLHttpRequest()
    {
        if(window.XMLHttpRequest)
        {
            XMLHttpReq=new XMLHttpRequest();
        }
        else if(window.ActiveXObject)
        {
            //IE7之前的版本
            try
            {
                XMLHttpReq=new ActiveXObject("Msxml2.XMLHTTP");
            }
            catch(e)
            {
                try
                {
                    XMLHttpReq=new ActiveXObject("Microsoft.XMLHTTP");
                }
                catch(e){}
            }
        }
    }
    //处理服务器响应
    function processResponse()
    {
        if(XMLHttpReq(this).readyState==4)//判断和服务器连接的状态。
        {
            if(XMLHttpReq(this).status==200)//判断服务器响应状态：200正常;500内部错误；404路径错误/页面丢失
            {
                alert("服务器发挥的数据时："+XMLHttpReq.responseText);//返回响应的数据
            }
            else{alert("页面异常");}
        }
    }
    //发送请求
    function sendRequest()
    {
        createXMLHttpRequest();//创建对象
        XMLHttpReq.open("POST",url,true);//连接服务器
        XMLHttpReq.setRequestHeader("Content-type","application/x-www-form-urlencoded")//s设置请求头
        XMLHttpReq.onreadystatechange=processResponse;//指定ajax状态改变时触发的回调函数
        XMLHttpReq.send("发送的数据");//发送请求，比如："name=lihognlei&age=18"
    }
    sendRequest();
</script>